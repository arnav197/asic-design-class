# ASIC Design Class

# First Session: Compiling a C program using GCC and RISC-V

## 1. Compiled C code over GCC (O1)
**1.1** A simple C code which calculates the sum of numbers upto 5 is run over GCC in the manner discussed. 
 
 Firstly, a text editor is used to write the code as shown below. We use leafpad.

<img src="imagesfirstsession\O1createfile.png" alt="Step 1.1" width="400"/> <br>

In the screenshot posted above, leafpad is summoned using the **leafpad sum1ton.c** command. Here, **sum1ton.c** is the C program file which contains our code. Therefore, write the code in it. And save it, obviously.

**1.2** Going ahead, compile the written C code in the manner shown below.

<img src="imagesfirstsession\O1gcccompilation.png" alt="Step 1.1" width="400"/> <br>

**gcc sum1ton.c** command compiles the C program and an executable is created. 

Also shown is the process to run the executable **a.out** which is the default executable generated by the gcc. The output can be made out, which is 15. **We will call it O1**.

## 2. Compiled C code over RISCV compiler.

Akin to what was done in the previous section, similar code is run using RISCV compiler. Two compiler flags O1 and Ofast are used. 

**2.1** Same C program is used and displayed using the *cat sum1ton.c* command. As shown in the image below, the command to compile using O1 compiler flag is shown.


<img src="imagesfirstsession\01.png" alt="Step 1.1" width="400"/> <br>

The following command does the compilation:

```
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```

**2.2** The next thing to do is to create object file. This file has the compiler's output. We can infer the number of instructions in the manner explained.

The following command can be used to observe the assembly code generated by the program:

```
riscv64-unknown-elf-objdump -d sum1ton.o | less
```

After navigating to the */main* section, one can calculate the number of instructions using O1 in the compile command.

<img src="imagesfirstsession\O1noofinstr.png" alt="Step 1.1" width="400"/> <br>

**One can infer the number of instructions to be 11** in this case, starting from 0x10184 to 0x101ac. 

**Note:** When the assembly instructions are displayed, *main* function can be accessed by typing /main on the command line argument. One can then go ahead and analyse the number of instructions by simply calculating or by analysing the Hexadecimal values of the base addresses of main function and the next succeeding function.

**2.3** Using Ofast compiler flag.

The exact steps of O1 flag are repeated barring the command. 

<img src="imagesfirstsession\ofast.png" alt="Step 1.1" width="400"/> <br>

The following command does the compilation again, but using Ofast, this time:

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
Similarly, the object file is created using the same command which was used for O1 flag. 

Navigate to the *main* section again by typing */main* in the command line argument. **After we infer the number of instructions, we can see they are 11 of them**. 

**Note:** Again, you can also calculate the number of instructions by referring the base address of the main function section and base address of the next occuring section. Refer to the image below.

<img src="imagesfirstsession\ofastinstr.png" alt="Step 1.1" width="400"/> <br>

**The number of instructions here come up to be 11 again.**


The primary reason behind this might occur is because the algorithm complexity is not high. Therefore, the underlying algorithm might not benefit from using Ofast, which seems to be the case here.
****






---











    
