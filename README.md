# ASIC Design Class

# First Session: Compiling a C program using GCC and RISC-V

## 1. Compiled C code over GCC (O1)
**1.1** A simple C code which calculates the sum of numbers upto 5 is run over GCC in the manner discussed. 
 
 Firstly, a text editor is used to write the code as shown below. We use leafpad.

<img src="imagesfirstsession\O1createfile.png" alt="Step 1.1" width="400"/> <br>

In the screenshot posted above, leafpad is summoned using the **leafpad sum1ton.c** command. Here, **sum1ton.c** is the C program file which contains our code. Therefore, write the code in it. And save it, obviously.

**1.2** Going ahead, compile the written C code in the manner shown below.

<img src="imagesfirstsession\O1gcccompilation.png" alt="Step 1.1" width="400"/> <br>

**gcc sum1ton.c** command compiles the C program and an executable is created. 

Also shown is the process to run the executable **a.out** which is the default executable generated by the gcc. The output can be made out, which is 15. **We will call it O1**.

## 2. Compiled C code over RISCV compiler.

Akin to what was done in the previous section, similar code is run using RISCV compiler. Two compiler flags O1 and Ofast are used. 

**2.1** Same C program is used and displayed using the *cat sum1ton.c* command. As shown in the image below, the command to compile using O1 compiler flag is shown.


<img src="imagesfirstsession\01.png" alt="Step 1.1" width="400"/> <br>

The following command does the compilation:

```
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```

**2.2** The next thing to do is to create object file. This file has the compiler's output. We can infer the number of instructions in the manner explained.

The following command can be used to observe the assembly code generated by the program:

```
riscv64-unknown-elf-objdump -d sum1ton.o | less
```

After navigating to the */main* section, one can calculate the number of instructions using O1 in the compile command.

<img src="imagesfirstsession\O1noofinstr.png" alt="Step 1.1" width="400"/> <br>

**One can infer the number of instructions to be 11** in this case, starting from 0x10184 to 0x101ac. 

**Note:** When the assembly instructions are displayed, *main* function can be accessed by typing /main on the command line argument. One can then go ahead and analyse the number of instructions by simply calculating or by analysing the Hexadecimal values of the base addresses of main function and the next succeeding function.

**2.3** Using Ofast compiler flag.

The exact steps of O1 flag are repeated barring the command. 

<img src="imagesfirstsession\ofast.png" alt="Step 1.1" width="400"/> <br>

The following command does the compilation again, but using Ofast, this time:

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
Similarly, the object file is created using the same command which was used for O1 flag. 

Navigate to the *main* section again by typing */main* in the command line argument. **After we infer the number of instructions, we can see they are 11 of them**. 

**Note:** Again, you can also calculate the number of instructions by referring the base address of the main function section and base address of the next occuring section. Refer to the image below.

<img src="imagesfirstsession\ofastinstr.png" alt="Step 1.1" width="400"/> <br>

**The number of instructions here come up to be 11 again.**


The primary reason why this might occur is because the algorithm complexity is not high. Therefore, the underlying algorithm might not benefit from using Ofast, which seems to be the case here.

# SECOND SESSION:  Program output and Debugging 

## The objective is to confirm the output of the program is same as the previous case and to debug the object dump file.

## 1. Program Output
1.1 Compile the program again using riscv gcc using the command: 

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
1.2 Following command runs the object file and displays the result: 
```
spike pk sum1ton.o
```
The output is as follows: 
<img src="imagessessiontwo\2ses1.png" alt="Step 1.1" width="400"/> <br>
**The output can be inferred from the snapshot above. It is 15, which is equal to the previous cases.**

1.3 Again, using the command
```
riscv-unknown-elf-objdump -d sum1ton.o | less
```
will display the object dump, where all the instructions are listed to analyse and infer.

Snapshot of object dump: 

<img src="imagessessiontwo\objdump.png" alt="Step 1.1" width="400"/> <br>

**This will be essential for debugging.**

## 2. DEBUGGING

To debug is to go through every instruction, specified by a memory address, and analyse what the instruction performs.

**2.1** Here, we modify the program counter such that it stops at the memory address of the first instruction of the obj dump file using the command: 
```
spike -d pk sum1ton.o
until pc 0 100b0
```
This will open a debugger. **Also, notice that the memory address of the first instruction is 100b0, inferred through the obj dump snapshot.**

The command will stop the program counter at 100b0, all the intructions will thereon commence only after the user presses the enter button.


**2.2** The intruction correspondong to the first memory address 100b0, is: *lui a0, 0x21*. We will not delve into the deteils of the instruction but our task is to observe whether the instruction worked or it did not i.e was it able to run the lui command.

For that, we will observe the contents of register a0, before running the operation. Have a look at the snapshot below.

<img src="imagessessiontwo\reg_a0.png" alt="Step 1.1" width="400"/> <br>

It can be seen using the command:

```
reg 0 a0
```
that the contents of the register a0 before the instruction was 0x......01, later it was 0x....21000. Use the same command to assess the contents of the register again after the instruction was run using the "Enter" key.

Clearly, the value stored in a0 was appended as per the instruction.

**2.3** Moving on, similar steps are followed for the next instruction. 

From the object dump file, the next instruction is *addi sp,sp, -16*. sp is an appreviation for Stack Pointer which is also a register. Run the command:

```
reg 0 sp
```
Take reference from the snapshot obtained.

<img src="imagessessiontwo\reg_sp.png" alt="Step 1.1" width="400"/> <br>

The value before the instruction is 0x0000003ffffffb50. Once we press enter, we can observe that the value is appended by -16. 

The new value stored in the register sp can accesses using the same command as above, which is 0x0000003ffffffb40.

**Note:**
1. *lui* and *addi* are immediate instructions. *lui* stands for Left Upper Immediate, where 'Upper' refers to the first 16 bits. 
2. *addi* adds the content of the source register and immediate and goes on to store the result in the destination register. 



# Third Session 

# 1. Identifying Instruction Types

## As the activity suggests, intruction types are being indentified for the instructions provided. The 32bit code is identified to do so. Each instruction type has it's own instruction format. 



**What are instruction formats in RISCV?** 

Instruction formats can be considered as a 'contract' betwwen the assembly language and the hardware where, if the assembly language 'demands' to execute the instruction, the hardware knows exactly what to do with it. Therefore, there exists certain instructions and their respective format for the hardware to understand. They are made up of series of 0s and 1s depending upon their format, which includes the type of operation, location of data, etc.

There exists 6 types of instruction formats in RISCV.

* R type

    + 'R' here stands for register. 
    + This type inculcates all arithmetic and logical operations.
    +  They are used for operations that involve 3 registers.
    +  The format of R-type instructions is consistent and includes fields for specifying two source registers, one destination register, a function code to specify the operation, and an opcode.
    +  Examples: ADD, SUB, OR, XOR, etc.
    +  The instruction format is as follows: 
  
  <img src="imagessessionthree\rtype.png" alt="Step 1.1" width="400"/> <br>
    + funct7 (7 bits): Function code for additional instruction differentiation.
    + rs2 (5 bits): Second source register.
    + rs1 (5 bits): First source register.
    + funct3 (3 bits): Function code for primary instruction differentiation.
    + rd (5 bits): Destination register.
    + opcode (7 bits): Basic operation code for R-type instructions (0110011 for integer operations).
* I type

    + I-type instructions in the RISC-V architecture are used for operations that involve an immediate value along with one or two registers.
    +  These instructions typically perform operations such as arithmetic with immediate values, load operations, and certain branch instructions.
    +  The format of I-type instructions includes fields for a source register, destination register, an immediate value, a function code, and an opcode.
    +  The instruction format is as follows:
  
  <img src="imagessessionthree\itype.png" alt="Step 1.1" width="400"/> <br>
    + immediate (12 bits): Immediate value used for operations.
    + rs1 (5 bits): Source register.
    + funct3 (3 bits): Function code for instruction differentiation.
    + rd (5 bits): Destination register.
    + opcode (7 bits): Basic operation code for I-type instructions.
  
* S Type 
  
    + S-type instructions in the RISC-V architecture are used for store operations, where data is stored from a register into memory.
   + The format of S-type instructions includes fields for two source registers, an immediate value that determines the memory offset, a function code, and an opcode.
   +  The format is as follows: 

  <img src="imagessessionthree\stype.png" alt="Step 1.1" width="400"/> <br>
    + imm[11:5] (7 bits): Upper 7 bits of the immediate value.
    + rs2 (5 bits): Second source register (contains the data to be stored).
    + rs1 (5 bits): First source register (base address register).
    + funct3 (3 bits): Function code for instruction differentiation.
    + imm[4:0] (5 bits): Lower 5 bits of the immediate value.
    + opcode (7 bits): Basic operation code for S-type instructions.

* B Type

    + B-type instructions in the RISC-V architecture are used for conditional branch operations.
    +  These instructions are designed to alter the flow of execution based on comparisons between two registers. 
    +  The format of B-type instructions includes fields for two source registers, an immediate value that determines the branch offset, a function code, and an opcode.
    +  Following is the instruction format:
    
     <img src="imagessessionthree\btype.png" alt="Step 1.1" width="400"/> <br>
    + imm[12] (1 bit): The 12th bit of the immediate value.
    + imm[10:5] (6 bits): The 10th to 5th bits of the immediate value.
    + rs2 (5 bits): Second source register.
    + rs1 (5 bits): First source register.
    + funct3 (3 bits): Function code for instruction differentiation.
    + imm[4:1] (4 bits): The 4th to 1st bits of the immediate value.
    + imm[11] (1 bit): The 11th bit of the immediate value.
    + opcode (7 bits): Basic operation code for B-type instructions

* U Type

    + U-type instructions in the RISC-V architecture are used for operations involving large immediate values, typically for loading upper immediate values or computing addresses.
    +  The format of U-type instructions includes fields for a destination register, a large immediate value, and an opcode.
    +  The instruction format is as follows:
  
     <img src="imagessessionthree\utype.png" alt="Step 1.1" width="400"/> <br>
    + immediate[31:12] (20 bits): The upper 20 bits of the immediate value.
    + rd (5 bits): Destination register.
    + opcode (7 bits): Operation code for U-type instructions.
    + The immediate value is stored in the upper 20 bits of a 32-bit word, with the lower 12 bits set to zero when used in calculations.

* J type
    + J-type instructions in the RISC-V architecture are used for jump operations, allowing for altering the program control flow by jumping to a specified address.
    + These instructions are typically used for unconditional jumps, like calling functions or implementing loops.
    + Following is the instruction format: 
     
    <img src="imagessessionthree\jtype.png" alt="Step 1.1" width="400"/> <br>
    + imm[20] (1 bit): The 20th bit of the immediate value.
    + imm[10:1] (10 bits): The 10th to 1st bits of the immediate value.
    + imm[11] (1 bit): The 11th bit of the immediate value.
    + imm[19:12] (8 bits): The 19th to 12th bits of the immediate value.
    + rd (5 bits): Destination register where the return address is stored.
    + opcode (7 bits): Operation code for J-type instructions.
   
  
  ## Decoding each instruction type provided: 

   1. ``` ADD r1, r2, r3 ```
  
        + Opcode for ADD = 0110011
        + rd = r1 = 00001
        + rs1 = r2 = 00010
        + rs2 = r3 = 00110
        + func3 = 000
        + func7 = 0000000
        + **R Type**
        + 32 Bit Instruction: 0000000_00110_00010_000_00001_0110011
  
   2. ``` SUB r3, r1, r2 ``` 
        + Opcode for SUB = 0110011
        + rd = r3 = 00110
        + rs1 = r1 = 00001
        + rs2 = r2 = 00010
        + func3 = 000
        + func7 = 0100000
        + **R Type**
        + 32 Bit Instruction: 0100000_00010_00001_000_00110_0110011
         
   3. ``` AND r2, r1, r3 ```
        + Opcode for AND = 0110011
        + rd = r2 = 00010
        + rs1 = r1 = 00001
        + rs2 = r3 = 00011
        + func3 = 111
        + func7 = 0000000
        + **R Type**
        + 32 Bit Instruction: 0000000_00011_00001_111_00010_0110011
         
    4. ``` OR r8, r2, r5 ```
        + Opcode for OR = 0110011
        + rd = r8 = 01000
        + rs1 = r2 = 00010
        + rs2 = r5 = 00101
        + func3 = 110
        + func7 = 0000000 
        + **R Type**
        + 32 Bit Instruction: 0000000_00101_00010_110_01000_0110011
    5. ``` XOR r8, r1, r4 ```
        + Opcode for XOR = 0110011
        + rd = r8 = 01000
        + rs1 = r1 = 00001
        + rs2 = r4 = 00100
        + func3 = 100
        + func7 = 0000000  
        + **R Type**      
        + 32 Bit Instruction: 0000000_00100_00001_100_01000_0110011
    6. ``` SLT r10, r2, r4 ```
  
        + Opcode for SLT  = 0110011
        + rd = r10 = 01100
        + rs1 = r2 = 00010
        + rs2 = r4 = 00100
        + func3 = 010
        + func7 = 0000000
        + **R Type**
        + 32 Bit Instruction: 0000000_00100_00010_010_01100_0110011
  
   4. ``` ADDI r12, r3, 5 ``` 
        + Opcode for ADDI = 0010011
        + rd = r12 = 01100
        + rs1 = r3 = 00110
        + imm[11:0] = 5 = 000000000101
        + func3 = 000
        + **I Type**
        + 32 Bit Instruction: 000000000101_00001_000_00110_0010011
         
   5. ``` SW r3, r1, 4 ```
        + Opcode for SW = 0100011
        + rs2 = r3 = 00100
        + rs1 = r1 = 00001
        + func3 = 010
        + imm[11:0] = 4 = 000000000100
        + **S Type**
        + 32 Bit Instruction: 0000000_00100_00001_010_0100_0100011
    6. ``` SRL r16, r11, r2 ```
        + Opcode for SRL = 0110011
        + rd = r16 = 10000
        + rs1 = r11 = 01011
        + rs2 = r2 = 00010
        + func3 = 101
        + func7 = 0000000 
        + **R Type**
        + 32 Bit Instruction: 0000000_00010_01011_101_10000_0110011
    7.  ``` BNE r0, r1 , 20 ```
        + Opcode for BNE = 1100011
        
        + rs1 = r0 = 00000
        + rs2 = r1 = 00001
        + func3 = 001
        + imm[12:1] = 20 = 000000010100
        + **B Type**   
        + 32 Bit Instruction: 0_000001_00001_00000_001_1010_0_1100011
    8.  ``` BEQ r0, r0, 15 ```
        + Opcode for BEQ = 1100011
        + rs1 = r0 = 00000
        + rs2 = r0 = 00000
        + Imm[12:1] = 15 = 000000001111
        + func3 = 000
        + **B Type**  
        + 32 Bit Instruction: 0_000000_00000_00000_000_1111_0_1100011
    9.  ``` LW r13, r11, 2 ```
        + Opcode for LW = 0000011
        + rd = r13 = 01101
        + rs1 = r11 = 01011     
        + imm[11:0] = 000000000010
        + func3 = 010
        + **I Type**
        + 32 Bit Instruction: 000000000010_01011_010_01101_00001
    10. ``` SLL r15, r11, r2 ```
        + Opcode for SLL = 0110011
        + rd = r15 = 01111
        + rs1 = r11 = 01011
        + rs2 = r2 = 00010
        + func3 = 001
        + func7 = 0000000
        + **R Type**     
        + 32 Bit Instruction: 0000000_00010_01011_001_01111_0110011
    
    Therefore, the instructions have been matched to their corresponding types and their 32 bit layout has been constructed as per their respective format. 

# 2. Running assembly instructions in accordance to a provided Verilog code in a RISCV processor.

There exists variations in the bit pattern of the instructions provided. Firstly, for the provided verilog code and the instructions, following is the Bit pattern and the ISA according to the code.
|Operation	     |        Hardcoded ISA |   Bit Pattern (Hardcoded)
|----------------|----------------------|----------------------------------------------------
|ADD R6, R2, R1	 |	      32'h02208300  |   0000001 00010 00001 000 00110 0000000
|SUB R7, R1, R2	 |	      32'h02209380  |   0000001 00010 00001 001 00111 0000000
|AND R8, R1, R3	 |        32'h0230a400  |   0000001 00011 00001 010 01000 0000000
|OR R9, R2, R5	 |        32'h02513480  |   0000001 00101 00010 011 01001 0000000
|XOR R10, R1, R4 |	      32'h0240c500  |   0000001 00100 00001 100 01010 0000000
|SLT R1, R2, R4	 |	      32'h02415580  |   0000001 00100 00010 101 01011 0000000   
|ADDI R12, R4, 5 |	      32'h00520600  |   000000000101 00100 000 01100 0000000   
|**BEQ** R0, R0, 15	 |	  32'h00f00002  |   0 000000 01111 00000 000 0000 0 0000010
|**SW** R3, R1, 2	 |	  32'h00209181  |   0000000 00010 00001 001 00011 0000001
|LW R13, R1, 2	 |	      32'h00208681  |   000000000010 00001 000 01101 0000001  
|SRL R16, R14, R2|        32'h00271803  |   0000000 00010 01110 001 10000 0000011
|SLL R15, R1, R2 |	      32'h00208783  |   0000000 00010 00001 000 01111 0000011


For the custom instructions provided, 

|Operation	     |        RISCV ISA     |   Bit Pattern (RISCV)
|----------------|----------------------|----------------------------------------------------
|ADD r1, r2, r3  |	      32'h006100B3  |   0000000 00110 00010 000 00001 0110011
|SUB r3, r1, r2	 |	      32'h40208333  |   0100000 00010 00001 000 00110 0110011
|AND r2, r1, r3	 |        32'h0230a400  |   0000000 00011 00001 111 00010 0110011
|OR r8, r2, r5	 |        32'h0030F133  |   0000000 00101 00010 110 01000 0110011
|XOR r8, r1, r4  |	      32'h0040C433  |   0000000 00100 00001 100 01000 0110011
|SLT r10, r2, r4 |	      32'h00412633  |   0000000 00100 00010 010 01100 0110011 
|ADDI r12, r3, 5 |	      32'h00508313  |   000000000101 00001 000 00110 0010011   
|SW r3, r1, 4    |	      32'h00205223  |   0000000 00100 00001 010 0100 0100011
|SRL r16, r11, r2|	      32'h0025D833  |   0000000 00010 01011 101 10000 0110011
|BNE r0, r1, 20	 |	      32'h02101A63  |   0 000001 00001 00000 001 1010 0 1100011  
|LW r13, r11, 2  |        32'h000969A1  |   000000000010 01011 010 01101 00001
|SLL r15, r11, r2|	      32'h002597B3  |   0000000 00010 01011 001 01111 0110011
|BEQ r0, r0, 15  |        32'h00000F63  |   0 000000 00000 00000 000 1111 0 1100011

It is to observe that, although the intruction format which is visible in the bit pattern is same for both RISCV ISA and the Hardcoded ISA. The difference lies in the actual representation of the constituent elements, primarily in **func3, func7 and the opcode**.

 For example, if we consider the opcode for ADD instruction, it is 01100110 for RISCV but according to the hardcoded ISA, it comes out to be 0000000. This is similar for SUB instruction as well. Moreover, for SUB instruction, the func3 is 001 for hardcoded ISA and it is 000 for RISCV ISA. The func7 too varies for ADD, SUB, AND, OR, XOR instructions in the harcoded ISA and the RISCV ISA. In short, 
 1. For R type instructions: func3, func7 and the opcode are different.
 2. For I type instructions: opcode is different. 
 3. For B type instructions: opcode is different.
   
Moving on, the snapshots of the waveform/signals of the custom instructions are attached below. The appropriate signals required for each type of instructions are visible in the snapshot.

1. ADD r1, r2, r3


<img src="imagessessionthree\add.png" alt="Step 1.1" width="400"/> <br>  
 
2. SUB r3, r1, r2


<img src="imagessessionthree\sub.png" alt="Step 1.1" width="400"/> <br> 


3. AND r2, r1, r3


<img src="imagessessionthree\and.png" alt="Step 1.1" width="400"/> <br> 

4. OR r8, r2, r5


<img src="imagessessionthree\or.png" alt="Step 1.1" width="400"/> <br> 

5. XOR r8, r1, r4


<img src="imagessessionthree\xor.png" alt="Step 1.1" width="400"/> <br> 

6. SLT r10, r2, r4


<img src="imagessessionthree\slt.png" alt="Step 1.1" width="400"/> <br> 

7. ADDI r12, r3, 5


<img src="imagessessionthree\addi.png" alt="Step 1.1" width="400"/> <br> 


8. SW r3, r1, 4


<img src="imagessessionthree\sw.png" alt="Step 1.1" width="400"/> <br> 

 

9.  BNE r0, r1, 20


<img src="imagessessionthree\bne.png" alt="Step 1.1" width="400"/> <br> 

10.  BEQ r0, r0, 15


<img src="imagessessionthree\beq.png" alt="Step 1.1" width="400"/> <br> 

11.  LW r13, r11, 2


<img src="imagessessionthree\lw.png" alt="Step 1.1" width="400"/> <br> 

12.  SLL r15, r11, r2


 <img src="imagessessionthree\sll.png" alt="Step 1.1" width="400"/> <br> 



# Fourth Session: Executing C Code to Print/Determine Prime Numbers Up to a Certain Limit Using the Sieve of Eratosthenes Algorithm 


In this lab, we are repeating the tasks from the first session, but with a different C code implementation.

# **Sieve of Eratosthenes**

The **Sieve of Eratosthenes** is a well-known algorithm with a predictable pattern of execution that heavily relies on memory access and bitwise operations. It is an ancient algorithm used to find all prime numbers up to a specified integer. It works by iteratively marking the multiples of each prime number starting from 2. The numbers that remain unmarked after all the multiples have been marked are prime. Comparing its performance on different architectures and compilers can reveal how well each handles large-scale, memory-intensive operations, and the efficiency of loop unrolling, bitwise optimizations, and cache utilization. 

**Key Aspects:**

* **Memory Allocation and Access**: The algorithm uses a dynamically allocated boolean array to mark non-prime numbers, which tests memory allocation and access patterns.

* **Bitwise Operations and Loops**: The core of the algorithm involves setting bits (marking non-primes) in a loop, testing how well the compiler optimizes such operations.


* **Time Complexity**: The algorithm is efficient but still requires significant computational effort for large limits (like 1,000,000), making it a good performance benchmark.



## 1. Over GCC

1.1 Refer to the C code saved in file *sieve.c*: 

```
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h> // Include this header for malloc and free
#include <math.h>

void sieve_of_eratosthenes(int limit) {
    // Allocate memory for the prime array
    bool *prime = (bool *)malloc((limit + 1) * sizeof(bool));
    if (prime == NULL) {
        printf("Memory allocation failed\n");
        return;
    }

    // Initialize all entries as true
    for (int i = 0; i <= limit; i++) {
        prime[i] = true;
    }

    prime[0] = prime[1] = false; // 0 and 1 are not primes

    for (int p = 2; p * p <= limit; p++) {
        if (prime[p]) {
            for (int i = p * p; i <= limit; i += p) {
                prime[i] = false;
            }
        }
    }

    // Print the prime numbers
    printf("Prime numbers up to %d are:\n", limit);
    for (int p = 2; p <= limit; p++) {
        if (prime[p]) {
            printf("%d ", p);
        }
    }
    printf("\n");

    // Free the allocated memory
    free(prime);
}

int main() {
    int limit;

    printf("Enter the limit up to which you want to find prime numbers: ");
    scanf("%d", &limit);

    if (limit<2) {
        printf("There are no prime numbers less than 2. \n");
    }   else {
        sieve_of_eratosthenes(limit);
    }
    return 0;
}
```
1.2 The output snapshot is pasted below: 

<img src="imagessessionfour\gccop.png" alt="Step 1.1" width="400"/> <br>  
 
***sieve_gcc.out*** is the name of the output file 

Note: The commands used are the same as of first session apart from the file names. 


## 2. Over RISCV GCC (O1 and Ofast) 


### 2.1 O1 Compiler Flag

**2.1.1** To compile using O1 compiler flag use the following command: 

``` 
riscv64-unknown-elf-gcc -O1 -mabi=lp64i -march=rv64i -o sieveO1 sieve.c
```

***sieveO1*** is the output file after compiler. This is accessed using the command:

``` 
spike pk sieve01
```


**2.1.2** The output is the same as GCC and the following: 

<img src="imagessessionfour\O1_op.png" alt="Step 1.1" width="400"/> <br> 


**2.1.3** To gather information about the number of instructions use the following command: 

```
riscv64-unknown-elf-objdump -d sieveO1
```

Again, navigate to the /main section and calculate the number of instructions as done in session two and the number of instructions can be inferred to be 21.

Refer to the snapshot below: 

<img src="imagessessionfour\01instructions.png" alt="Step 1.1" width="400"/> <br> 




### 2.2 Ofast Compiler Flag

**2.2.1** To compile using Ofast compiler flag use the following command: 

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sieveOfast sieve.c
```

***sieveOfast*** is the output file after compilation.

**2.2.2** The output is again, the same as GCC and RISCV-GCC with O1 compiler flag. To access the output file using riscv emulator spike, use the command: 

```
spike pk sieveOfast
```



**2.2.3** Use the same step as above (for O1 flag) to gather information about the number of instructions. 

Refer to the snapshot below: 

<img src="imagessessionfour\Ofastinstructions.png" alt="Step 1.1" width="400"/> <br> 




The number of instructions are 21 again. 



# Fifth Session: Digital Logic with TL Verilog and Makerchip

## What is TL Verilog? 
**TL-Verilog** is a modern hardware description language designed to simplify and accelerate digital design by reducing the verbosity and complexity commonly associated with traditional hardware languages like Verilog and VHDL. TL-Verilog introduces a novel approach to design, emphasizing transactional-level modeling and making it easier to handle complex pipelined designs. With TL-Verilog, designers can focus more on the behavior of the hardware rather than low-level implementation details, thanks to features like automatic pipeline handling, clean and concise syntax, and built-in support for powerful abstraction mechanisms.

## Makerchip

Makerchip is an online platform and integrated development environment (IDE) designed to facilitate the design and simulation of digital circuits using TL-Verilog and traditional Verilog. It provides an accessible and user-friendly environment where users can write, simulate, and visualize their hardware designs directly in a web browser, without the need for installing any software.


## Developing a **Combinational Logic** for a Simple Calculator in TL Verilog using Makerchip


A basic calculator is implemented using a 4x1 multiplexer. It performs the following primitive calculations: 
   
1. ADD: ```$sum[31:0] = $val1[31:0] + $val2[31:0];```
2. SUB: ``$diff[31:0] = $val1[31:0] - $val2[31:0];``
3. QUOT: ``$quot[31:0] = $val1[31:0] / $val2[31:0];``
4. PROD: `$prod[31:0] = $val1[31:0] * $val2[31:0];`  

The above operations are implemented, as mentioned using a 4x1 MUX. The same can be implemented in TL Verilog using ternary operators. Take a look at the code below to do so: 


```
$out[31:0] = ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
         ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
         ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                          $quot;   // If sel is 11, select quot

```

The select signal and the operands for the calculators are chosen at random using the `` $random`` command. 

Have a look at the complete TL Verilog code for reference: 

```
$val1[31:0]  = $rand1[3:0];
   $val2[31:0] = $rand2[3:0];
   
   $sum[31:0] = $val1[31:0] + $val2[31:0];
   $diff[31:0] = $val1[31:0] - $val2[31:0];
   $prod[31:0] = $val1[31:0] * $val2[31:0];
   $quot[31:0] = $val1[31:0] / $val2[31:0];
   
   $sel[1:0] = $rand3[1:0];
    
   
   $out[31:0] = ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
         ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
         ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                          $quot;   // If sel is 11, select quot
```

The snapshot of the above activity is attached below:


<img src="imagessessionfive\calc_mux_1.png" alt="Step 1.1" width="400"/> <br> 

## Adding **Sequential Logic** to the Calculator 

Sequential Logic is implemented by using a clock signal. The signals produced at the offset of each clock might be of importance/use in the program which might need those values to perform operations on them. Therefore we use the ```>>(integer)$(operand_name)``` operator to access signals from clock signal which we require.

### Free Running Counter 
Firstly, we shall implement a Free Running Counter in TL Verilog using Makerchip.

The following code acts as a simple free running counter with a reset value of 0. The counter adds integer 1 to $num1 at each clock. This is done so in the following manner in TL Verilog: 

``` $num1[31:0] = $reset ? 0 : >>1$num1[31:0] + 1; ```

The value stored in $num1[31:0] is utilized using the operator mentioned above for a working model of a counter.

Refer to the snapshot below for reference: 

<img src="imagessessionfive\sq_logic_counter.png" alt="Step 1.1" width="400"/> <br> 

### Sequential Calculator 
As mentioned , the introduction of sequential logic will introduce the utilization of values which are obtained from clock cycles which are different from the ones where the operations are performed. This was seen in a simple manner in the previous example of a Free Running Counter as well. 


Moving on, our calculator is now modified to "hold" a value. This is done so, in the hardware, using a Flip-Flop. The value stored in the $out[31:0] is now fed to $val1[31:0] from our calculator example. 

This modification is done in the following manner: 

```$val1[31:0]  = >>1$out[31:0]; ```  

Therefore, the value in the output from the subsequent cycle is fed in as our new input. 

Practicallly speaking, calculators need a reset button as well, this will hold the output @ 0. The reset option is added into the 4x1 multiplexer code in the following manner: 
```
$out[31:0] = $reset ? 0 :($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
         ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
         ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                          $quot;   // If sel is 11, select quot
```
This can be inferred more clearly in the snapshot below: 

<img src="imagessessionfive\sq_calc_1.png" alt="Step 1.1" width="400"/> <br> 

From the snapshot, it can be seen that whenever the reset is HIGH, the output is set to 0. The calculator now performs all of it's regular defined operations, albeit now it has one of it's input taken from the output of the previous cycle. 

## Pipelined Logic 

In Verilog, pipelining is often implemented by designing a series of sequential stages where each stage is a separate module or a block of logic, and the stages are connected through registers. Each stage performs a part of the overall computation, and data moves from one stage to the next on each clock cycle.

### Assigning Counter and Calculator Developed in Previous Steps Into a Pipeline

As mentioned, pipelining is done so as to segregate operations or a block of logic which have some coherence or simply put, are associated with each together. In this example, **we shall put the Counter and the Calculator in a single pipeline and within a single pipeline stage as well.**

To initiate a pipeline, use the command: ``` |cacl ``` and make sure the indentation beyond this right.

To assign a pipelining stage to a set of operations, logic block or a module, use the command: ``` @int ```. This integer value depicts the pipelining stage with respect to the clock cycle. The calculator and the counter both, are added to this ``` |calc ``` pipeline in this following manner: 


```
|calc
      @1
             // Declare and initialize variables
         $reset[31:0] = *reset;

             // Generate random values and perform operations
         $val1[31:0] = >>1$out[31:0];
         $val2[31:0] = $rand2[3:0];

          // Perform arithmetic operations
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         $sel[1:0] = $rand3[1:0];

          // Update num1 and output based on selection

         $num1[31:0] = $reset ? 0 : >>1$num1[31:0] + 1;

         $out[31:0] = $reset ? 0 : ($sel == 2'b00) ? $sum  :  
                        ($sel == 2'b01) ? $diff :  
                        ($sel == 2'b10) ? $prod :  
                                         $quot;   

```
The waveforms and the corresponding figure generated is posted below for reference. 


<img src="imagessessionfive\pipeline1.png" alt="Step 1.1" width="400"/> <br>

### Cycle Calculator 

The code now is modified to use different stages of the pipeline. The 4x1 MUX is now pushed to the second stage while the following circuit is implemented: 

<img src="imagessessionfive\pipeline_ckt.png" alt="Step 1.1" width="400"/> <br>

Following is the modified code: 

```
|calc
      @1
             // Declare and initialize variables
         $reset = *reset;

             // Generate random values and perform operations
         $val1[31:0] = >>2$out[31:0];
         $val2[31:0] = $rand2[3:0];

          // Perform arithmetic operations
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         $sel[1:0] = $rand3[1:0];

          // Update num1 and output based on selection

         $num1[31:0] = $reset ? 0 : >>1$num1 + 1;
      @2
         $valid = !$num1;
         $rst_alt = $valid | $reset;
         $out[31:0] = $rst_alt ? 32'b0 : ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
                        ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
                        ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                                         $quot;   // If sel is 11, select quot


```
This retiming of the 4x1 MUX to the second clock using ``` @2 ``` is done to ease timings. Functionally speaking, everything else remains the same. Snapshot pasted below for reference: 

<img src="imagessessionfive\pipeline2.png" alt="Step 1.1" width="400"/> <br>


## Validity 

In TL-Verilog, validity is a key concept used to manage data flow through pipelines. It helps ensure that operations are only performed on valid data and prevents the unnecessary processing of invalid or stale data. This concept is essential in pipelined designs, where operations are spread across multiple clock cycles.

### Cycle Calculator with Validity 


Moving on, some changes have been made according to the circuit below: 

<img src="imagessessionfive\validity2.png" alt="Step 1.1" width="400"/> <br>

The enable signal for the 4x1 MUX has now been 'checked' using a valid signal in the following manner: 

``` $rst_alt = $valid | $num1; ``` This is a when condition now for the calculation to occur. We have therefore introduced a condition onto the operations of our calculator. Only if the condition is valid, will the calculator do it's task. This is encoded in the Multiplexer behaviour as an enable signal.
The multiplexer behaviour is also modified in accordance to this in the following manner: 
``` $out[31:0] = $rst_alt ? 32'b0 : ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
                        ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
                        ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                                         $quot;   // If sel is 11, select quot
```

Refer to the snapshot below with waveforms to verify the behaviour:

<img src="imagessessionfive\validity1.png" alt="Step 1.1" width="400"/> <br>

# Sixth Session:  Basic RISC-V CPU Micro-architecture 

The block diagram below vaguely represents the RISC-V CPU along with it's components: 

<img src="imagessessionfive\block.png" alt="Step 1.1" width="400"/> <br>

1. Program Counter: The Program Counter (PC) is a critical component in a RISC-V CPU (and any CPU in general), responsible for keeping track of the address of the next instruction to be executed. Understanding the role and implementation of the PC is fundamental when designing or working with a RISC-V CPU.
2. Instruction Fetch: Instruction fetch is the first stage in the instruction execution cycle of a RISC-V CPU. It involves retrieving the instruction pointed to by the Program Counter (PC) from memory so that it can be decoded and executed in subsequent stages.
3. Instruction Decode: Instruction decode is the second stage in the instruction execution cycle of a RISC-V CPU. After an instruction is fetched from memory, it needs to be interpreted, or "decoded," to understand what operation is to be performed and which operands are involved. The decoding process involves breaking down the binary instruction into its constituent fields, such as opcode, source registers, destination registers, and immediate values.
4. Register File Read: The read register file is a component that contains a collection of registers used to store data during instruction execution. Instructions typically involve accessing data from these registers, with the instruction indicating which registers to read. The retrieved data is then used as operands for operations carried out by the ALU or other CPU components.
5. Register File Write: In a RISC-V CPU, the register file write operation is a critical part of the instruction execution process, particularly during the write-back stage of the pipeline. This is where the results of computations or data from memory are written back to a register in the register file
6. ALU: The Arithmetic Logic Unit (ALU) in a RISC-V CPU is a key component responsible for performing arithmetic and logical operations. The ALU receives inputs from the register file or immediate values from instructions and produces results that are either stored back into registers, used for branching decisions, or forwarded to other components like memory.
7. Data Memory: n a RISC-V CPU, data memory is a crucial component that stores and retrieves data required during program execution. Data memory is involved in load and store operations, where data is either read from or written to memory.

### Program Counter
The program counter is implemented according to the condition specified in the lab as follows: 
`` $reset = *reset;
         $pc[31:0] = >>1$reset ? 0 : >>1$pc + 32'd4; 
``
The snapshot containing the waveform is pasted below: 

<img src="imagessessionfive\pc.png" alt="Step 1.1" width="400"/> <br>





















****






---











    
