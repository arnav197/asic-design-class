# ASIC Design Class

# First Session: Compiling a C program using GCC and RISC-V

## 1. Compiled C code over GCC (O1)
**1.1** A simple C code which calculates the sum of numbers upto 5 is run over GCC in the manner discussed. 
 
 Firstly, a text editor is used to write the code as shown below. We use leafpad.

<img src="imagesfirstsession\O1createfile.png" alt="Step 1.1" width="400"/> <br>

In the screenshot posted above, leafpad is summoned using the **leafpad sum1ton.c** command. Here, **sum1ton.c** is the C program file which contains our code. Therefore, write the code in it. And save it, obviously.

**1.2** Going ahead, compile the written C code in the manner shown below.

<img src="imagesfirstsession\O1gcccompilation.png" alt="Step 1.1" width="400"/> <br>

**gcc sum1ton.c** command compiles the C program and an executable is created. 

Also shown is the process to run the executable **a.out** which is the default executable generated by the gcc. The output can be made out, which is 15. **We will call it O1**.

## 2. Compiled C code over RISCV compiler.

Akin to what was done in the previous section, similar code is run using RISCV compiler. Two compiler flags O1 and Ofast are used. 

**2.1** Same C program is used and displayed using the *cat sum1ton.c* command. As shown in the image below, the command to compile using O1 compiler flag is shown.


<img src="imagesfirstsession\01.png" alt="Step 1.1" width="400"/> <br>

The following command does the compilation:

```
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```

**2.2** The next thing to do is to create object file. This file has the compiler's output. We can infer the number of instructions in the manner explained.

The following command can be used to observe the assembly code generated by the program:

```
riscv64-unknown-elf-objdump -d sum1ton.o | less
```

After navigating to the */main* section, one can calculate the number of instructions using O1 in the compile command.

<img src="imagesfirstsession\O1noofinstr.png" alt="Step 1.1" width="400"/> <br>

**One can infer the number of instructions to be 11** in this case, starting from 0x10184 to 0x101ac. 

**Note:** When the assembly instructions are displayed, *main* function can be accessed by typing /main on the command line argument. One can then go ahead and analyse the number of instructions by simply calculating or by analysing the Hexadecimal values of the base addresses of main function and the next succeeding function.

**2.3** Using Ofast compiler flag.

The exact steps of O1 flag are repeated barring the command. 

<img src="imagesfirstsession\ofast.png" alt="Step 1.1" width="400"/> <br>

The following command does the compilation again, but using Ofast, this time:

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
Similarly, the object file is created using the same command which was used for O1 flag. 

Navigate to the *main* section again by typing */main* in the command line argument. **After we infer the number of instructions, we can see they are 11 of them**. 

**Note:** Again, you can also calculate the number of instructions by referring the base address of the main function section and base address of the next occuring section. Refer to the image below.

<img src="imagesfirstsession\ofastinstr.png" alt="Step 1.1" width="400"/> <br>

**The number of instructions here come up to be 11 again.**


The primary reason why this might occur is because the algorithm complexity is not high. Therefore, the underlying algorithm might not benefit from using Ofast, which seems to be the case here.

# SECOND SESSION:  Program output and Debugging 

## The objective is to confirm the output of the program is same as the previous case and to debug the object dump file.

## 1. Program Output
1.1 Compile the program again using riscv gcc using the command: 

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
1.2 Following command runs the object file and displays the result: 
```
spike pk sum1ton.o
```
The output is as follows: 
<img src="imagessessiontwo\2ses1.png" alt="Step 1.1" width="400"/> <br>
**The output can be inferred from the snapshot above. It is 15, which is equal to the previous cases.**

1.3 Again, using the command
```
riscv-unknown-elf-objdump -d sum1ton.o | less
```
will display the object dump, where all the instructions are listed to analyse and infer.

Snapshot of object dump: 

<img src="imagessessiontwo\objdump.png" alt="Step 1.1" width="400"/> <br>

**This will be essential for debugging.**

## 2. DEBUGGING

To debug is to go through every instruction, specified by a memory address, and analyse what the instruction performs.

**2.1** Here, we modify the program counter such that it stops at the memory address of the first instruction of the obj dump file using the command: 
```
spike -d pk sum1ton.o
until pc 0 100b0
```
This will open a debugger. **Also, notice that the memory address of the first instruction is 100b0, inferred through the obj dump snapshot.**

The command will stop the program counter at 100b0, all the intructions will thereon commence only after the user presses the enter button.


**2.2** The intruction correspondong to the first memory address 100b0, is: *lui a0, 0x21*. We will not delve into the deteils of the instruction but our task is to observe whether the instruction worked or it did not i.e was it able to run the lui command.

For that, we will observe the contents of register a0, before running the operation. Have a look at the snapshot below.

<img src="imagessessiontwo\reg_a0.png" alt="Step 1.1" width="400"/> <br>

It can be seen using the command:

```
reg 0 a0
```
that the contents of the register a0 before the instruction was 0x......01, later it was 0x....21000. Use the same command to assess the contents of the register again after the instruction was run using the "Enter" key.

Clearly, the value stored in a0 was appended as per the instruction.

**2.3** Moving on, similar steps are followed for the next instruction. 

From the object dump file, the next instruction is *addi sp,sp, -16*. sp is an appreviation for Stack Pointer which is also a register. Run the command:

```
reg 0 sp
```
Take reference from the snapshot obtained.

<img src="imagessessiontwo\reg_sp.png" alt="Step 1.1" width="400"/> <br>

The value before the instruction is 0x0000003ffffffb50. Once we press enter, we can observe that the value is appended by -16. 

The new value stored in the register sp can accesses using the same command as above, which is 0x0000003ffffffb40.

**Note:**
1. *lui* and *addi* are immediate instructions. *lui* stands for Left Upper Immediate, where 'Upper' refers to the first 16 bits. 
2. *addi* adds the content of the source register and immediate and goes on to store the result in the destination register. 



# Third Session 

# 1. Identifying Instruction Types

## As the activity suggests, intruction types are being indentified for the instructions provided. The 32bit code is identified to do so. Each instruction type has it's own instruction format. 



**What are instruction formats in RISCV?** 

Instruction formats can be considered as a 'contract' betwwen the assembly language and the hardware where, if the assembly language 'demands' to execute the instruction, the hardware knows exactly what to do with it. Therefore, there exists certain instructions and their respective format for the hardware to understand. They are made up of series of 0s and 1s depending upon their format, which includes the type of operation, location of data, etc.

There exists 6 types of instruction formats in RISCV.

* R type

    + 'R' here stands for register. 
    + This type inculcates all arithmetic and logical operations.
    +  They are used for operations that involve 3 registers.
    +  The format of R-type instructions is consistent and includes fields for specifying two source registers, one destination register, a function code to specify the operation, and an opcode.
    +  Examples: ADD, SUB, OR, XOR, etc.
    +  The instruction format is as follows: 
  
  <img src="imagessessionthree\rtype.png" alt="Step 1.1" width="400"/> <br>
    + funct7 (7 bits): Function code for additional instruction differentiation.
    + rs2 (5 bits): Second source register.
    + rs1 (5 bits): First source register.
    + funct3 (3 bits): Function code for primary instruction differentiation.
    + rd (5 bits): Destination register.
    + opcode (7 bits): Basic operation code for R-type instructions (0110011 for integer operations).
* I type

    + I-type instructions in the RISC-V architecture are used for operations that involve an immediate value along with one or two registers.
    +  These instructions typically perform operations such as arithmetic with immediate values, load operations, and certain branch instructions.
    +  The format of I-type instructions includes fields for a source register, destination register, an immediate value, a function code, and an opcode.
    +  The instruction format is as follows:
  
  <img src="imagessessionthree\itype.png" alt="Step 1.1" width="400"/> <br>
    + immediate (12 bits): Immediate value used for operations.
    + rs1 (5 bits): Source register.
    + funct3 (3 bits): Function code for instruction differentiation.
    + rd (5 bits): Destination register.
    + opcode (7 bits): Basic operation code for I-type instructions.
  
* S Type 
  
    + S-type instructions in the RISC-V architecture are used for store operations, where data is stored from a register into memory.
   + The format of S-type instructions includes fields for two source registers, an immediate value that determines the memory offset, a function code, and an opcode.
   +  The format is as follows: 

  <img src="imagessessionthree\stype.png" alt="Step 1.1" width="400"/> <br>
    + imm[11:5] (7 bits): Upper 7 bits of the immediate value.
    + rs2 (5 bits): Second source register (contains the data to be stored).
    + rs1 (5 bits): First source register (base address register).
    + funct3 (3 bits): Function code for instruction differentiation.
    + imm[4:0] (5 bits): Lower 5 bits of the immediate value.
    + opcode (7 bits): Basic operation code for S-type instructions.

* B Type

    + B-type instructions in the RISC-V architecture are used for conditional branch operations.
    +  These instructions are designed to alter the flow of execution based on comparisons between two registers. 
    +  The format of B-type instructions includes fields for two source registers, an immediate value that determines the branch offset, a function code, and an opcode.
    +  Following is the instruction format:
    
     <img src="imagessessionthree\btype.png" alt="Step 1.1" width="400"/> <br>
    + imm[12] (1 bit): The 12th bit of the immediate value.
    + imm[10:5] (6 bits): The 10th to 5th bits of the immediate value.
    + rs2 (5 bits): Second source register.
    + rs1 (5 bits): First source register.
    + funct3 (3 bits): Function code for instruction differentiation.
    + imm[4:1] (4 bits): The 4th to 1st bits of the immediate value.
    + imm[11] (1 bit): The 11th bit of the immediate value.
    + opcode (7 bits): Basic operation code for B-type instructions

* U Type

    + U-type instructions in the RISC-V architecture are used for operations involving large immediate values, typically for loading upper immediate values or computing addresses.
    +  The format of U-type instructions includes fields for a destination register, a large immediate value, and an opcode.
    +  The instruction format is as follows:
  
     <img src="imagessessionthree\utype.png" alt="Step 1.1" width="400"/> <br>
    + immediate[31:12] (20 bits): The upper 20 bits of the immediate value.
    + rd (5 bits): Destination register.
    + opcode (7 bits): Operation code for U-type instructions.
    + The immediate value is stored in the upper 20 bits of a 32-bit word, with the lower 12 bits set to zero when used in calculations.

* J type
    + J-type instructions in the RISC-V architecture are used for jump operations, allowing for altering the program control flow by jumping to a specified address.
    + These instructions are typically used for unconditional jumps, like calling functions or implementing loops.
    + Following is the instruction format: 
     
    <img src="imagessessionthree\jtype.png" alt="Step 1.1" width="400"/> <br>
    + imm[20] (1 bit): The 20th bit of the immediate value.
    + imm[10:1] (10 bits): The 10th to 1st bits of the immediate value.
    + imm[11] (1 bit): The 11th bit of the immediate value.
    + imm[19:12] (8 bits): The 19th to 12th bits of the immediate value.
    + rd (5 bits): Destination register where the return address is stored.
    + opcode (7 bits): Operation code for J-type instructions.
   
  
  ## Decoding each instruction type provided: 

   1. ``` ADD r1, r2, r3 ```
  
        + Opcode for ADD = 0110011
        + rd = r1 = 00001
        + rs1 = r2 = 00010
        + rs2 = r3 = 00110
        + func3 = 000
        + func7 = 0000000
        + **R Type**
        + 32 Bit Instruction: 0000000_00110_00010_000_00001_0110011
  
   2. ``` SUB r3, r1, r2 ``` 
        + Opcode for SUB = 0110011
        + rd = r3 = 00110
        + rs1 = r1 = 00001
        + rs2 = r2 = 00010
        + func3 = 000
        + func7 = 0100000
        + **R Type**
        + 32 Bit Instruction: 0100000_00010_00001_000_00110_0110011
         
   3. ``` AND r2, r1, r3 ```
        + Opcode for AND = 0110011
        + rd = r2 = 00010
        + rs1 = r1 = 00001
        + rs2 = r3 = 00011
        + func3 = 111
        + func7 = 0000000
        + **R Type**
        + 32 Bit Instruction: 0000000_00011_00001_111_00010_0110011
         
    4. ``` OR r8, r2, r5 ```
        + Opcode for OR = 0110011
        + rd = r8 = 01000
        + rs1 = r2 = 00010
        + rs2 = r5 = 00101
        + func3 = 110
        + func7 = 0000000 
        + **R Type**
        + 32 Bit Instruction: 0000000_00101_00010_110_01000_0110011
    5. ``` XOR r8, r1, r4 ```
        + Opcode for XOR = 0110011
        + rd = r8 = 01000
        + rs1 = r1 = 00001
        + rs2 = r4 = 00100
        + func3 = 100
        + func7 = 0000000  
        + **R Type**      
        + 32 Bit Instruction: 0000000_00100_00001_100_01000_0110011
    6. ``` SLT r10, r2, r4 ```
  
        + Opcode for SLT  = 0110011
        + rd = r10 = 01100
        + rs1 = r2 = 00010
        + rs2 = r4 = 00100
        + func3 = 010
        + func7 = 0000000
        + **R Type**
        + 32 Bit Instruction: 0000000_00100_00010_010_01100_0110011
  
   4. ``` ADDI r12, r3, 5 ``` 
        + Opcode for ADDI = 0010011
        + rd = r12 = 01100
        + rs1 = r3 = 00110
        + imm[11:0] = 5 = 000000000101
        + func3 = 000
        + **I Type**
        + 32 Bit Instruction: 000000000101_00001_000_00110_0010011
         
   5. ``` SW r3, r1, 4 ```
        + Opcode for SW = 0100011
        + rs2 = r3 = 00100
        + rs1 = r1 = 00001
        + func3 = 010
        + imm[11:0] = 4 = 000000000100
        + **S Type**
        + 32 Bit Instruction: 0000000_00100_00001_010_0100_0100011
    6. ``` SRL r16, r11, r2 ```
        + Opcode for SRL = 0110011
        + rd = r16 = 10000
        + rs1 = r11 = 01011
        + rs2 = r2 = 00010
        + func3 = 101
        + func7 = 0000000 
        + **R Type**
        + 32 Bit Instruction: 0000000_00010_01011_101_10000_0110011
    7.  ``` BNE r0, r1 , 20 ```
        + Opcode for BNE = 1100011
        
        + rs1 = r0 = 00000
        + rs2 = r1 = 00001
        + func3 = 001
        + imm[12:1] = 20 = 000000010100
        + **B Type**   
        + 32 Bit Instruction: 0_000001_00001_00000_001_1010_0_1100011
    8.  ``` BEQ r0, r0, 15 ```
        + Opcode for BEQ = 1100011
        + rs1 = r0 = 00000
        + rs2 = r0 = 00000
        + Imm[12:1] = 15 = 000000001111
        + func3 = 000
        + **B Type**  
        + 32 Bit Instruction: 0_000000_00000_00000_000_1111_0_1100011
    9.  ``` LW r13, r11, 2 ```
        + Opcode for LW = 0000011
        + rd = r13 = 01101
        + rs1 = r11 = 01011     
        + imm[11:0] = 000000000010
        + func3 = 010
        + **I Type**
        + 32 Bit Instruction: 000000000010_01011_010_01101_00001
    10. ``` SLL r15, r11, r2 ```
        + Opcode for SLL = 0110011
        + rd = r15 = 01111
        + rs1 = r11 = 01011
        + rs2 = r2 = 00010
        + func3 = 001
        + func7 = 0000000
        + **R Type**     
        + 32 Bit Instruction: 0000000_00010_01011_001_01111_0110011
    
    Therefore, the instructions have been matched to their corresponding types and their 32 bit layout has been constructed as per their respective format. 

# 2. Running assembly instructions in accordance to a provided Verilog code in a RISCV processor.

There exists variations in the bit pattern of the instructions provided. Firstly, for the provided verilog code and the instructions, following is the Bit pattern and the ISA according to the code.
|Operation	     |        Hardcoded ISA |   Bit Pattern (Hardcoded)
|----------------|----------------------|----------------------------------------------------
|ADD R6, R2, R1	 |	      32'h02208300  |   0000001 00010 00001 000 00110 0000000
|SUB R7, R1, R2	 |	      32'h02209380  |   0000001 00010 00001 001 00111 0000000
|AND R8, R1, R3	 |        32'h0230a400  |   0000001 00011 00001 010 01000 0000000
|OR R9, R2, R5	 |        32'h02513480  |   0000001 00101 00010 011 01001 0000000
|XOR R10, R1, R4 |	      32'h0240c500  |   0000001 00100 00001 100 01010 0000000
|SLT R1, R2, R4	 |	      32'h02415580  |   0000001 00100 00010 101 01011 0000000   
|ADDI R12, R4, 5 |	      32'h00520600  |   000000000101 00100 000 01100 0000000   
|**BEQ** R0, R0, 15	 |	  32'h00f00002  |   0 000000 01111 00000 000 0000 0 0000010
|**SW** R3, R1, 2	 |	  32'h00209181  |   0000000 00010 00001 001 00011 0000001
|LW R13, R1, 2	 |	      32'h00208681  |   000000000010 00001 000 01101 0000001  
|SRL R16, R14, R2|        32'h00271803  |   0000000 00010 01110 001 10000 0000011
|SLL R15, R1, R2 |	      32'h00208783  |   0000000 00010 00001 000 01111 0000011


For the custom instructions provided, 

|Operation	     |        RISCV ISA     |   Bit Pattern (RISCV)
|----------------|----------------------|----------------------------------------------------
|ADD r1, r2, r3  |	      32'h006100B3  |   0000000 00110 00010 000 00001 0110011
|SUB r3, r1, r2	 |	      32'h40208333  |   0100000 00010 00001 000 00110 0110011
|AND r2, r1, r3	 |        32'h0230a400  |   0000000 00011 00001 111 00010 0110011
|OR r8, r2, r5	 |        32'h0030F133  |   0000000 00101 00010 110 01000 0110011
|XOR r8, r1, r4  |	      32'h0040C433  |   0000000 00100 00001 100 01000 0110011
|SLT r10, r2, r4 |	      32'h00412633  |   0000000 00100 00010 010 01100 0110011 
|ADDI r12, r3, 5 |	      32'h00508313  |   000000000101 00001 000 00110 0010011   
|SW r3, r1, 4    |	      32'h00205223  |   0000000 00100 00001 010 0100 0100011
|SRL r16, r11, r2|	      32'h0025D833  |   0000000 00010 01011 101 10000 0110011
|BNE r0, r1, 20	 |	      32'h02101A63  |   0 000001 00001 00000 001 1010 0 1100011  
|LW r13, r11, 2  |        32'h000969A1  |   000000000010 01011 010 01101 00001
|SLL r15, r11, r2|	      32'h002597B3  |   0000000 00010 01011 001 01111 0110011
|BEQ r0, r0, 15  |        32'h00000F63  |   0 000000 00000 00000 000 1111 0 1100011

It is to observe that, although the intruction format which is visible in the bit pattern is same for both RISCV ISA and the Hardcoded ISA. The difference lies in the actual representation of the constituent elements, primarily in **func3, func7 and the opcode**.

 For example, if we consider the opcode for ADD instruction, it is 01100110 for RISCV but according to the hardcoded ISA, it comes out to be 0000000. This is similar for SUB instruction as well. Moreover, for SUB instruction, the func3 is 001 for hardcoded ISA and it is 000 for RISCV ISA. The func7 too varies for ADD, SUB, AND, OR, XOR instructions in the harcoded ISA and the RISCV ISA. In short, 
 1. For R type instructions: func3, func7 and the opcode are different.
 2. For I type instructions: opcode is different. 
 3. For B type instructions: opcode is different.
   
Moving on, the snapshots of the waveform/signals of the custom instructions are attached below. The appropriate signals required for each type of instructions are visible in the snapshot.

1. ADD r1, r2, r3


<img src="imagessessionthree\add.png" alt="Step 1.1" width="400"/> <br>  
 
2. SUB r3, r1, r2


<img src="imagessessionthree\sub.png" alt="Step 1.1" width="400"/> <br> 


3. AND r2, r1, r3


<img src="imagessessionthree\and.png" alt="Step 1.1" width="400"/> <br> 

4. OR r8, r2, r5


<img src="imagessessionthree\or.png" alt="Step 1.1" width="400"/> <br> 

5. XOR r8, r1, r4


<img src="imagessessionthree\xor.png" alt="Step 1.1" width="400"/> <br> 

6. SLT r10, r2, r4


<img src="imagessessionthree\slt.png" alt="Step 1.1" width="400"/> <br> 

7. ADDI r12, r3, 5


<img src="imagessessionthree\addi.png" alt="Step 1.1" width="400"/> <br> 


8. SW r3, r1, 4


<img src="imagessessionthree\sw.png" alt="Step 1.1" width="400"/> <br> 

 

9.  BNE r0, r1, 20


<img src="imagessessionthree\bne.png" alt="Step 1.1" width="400"/> <br> 

10.  BEQ r0, r0, 15


<img src="imagessessionthree\beq.png" alt="Step 1.1" width="400"/> <br> 

11.  LW r13, r11, 2


<img src="imagessessionthree\lw.png" alt="Step 1.1" width="400"/> <br> 

12.  SLL r15, r11, r2


 <img src="imagessessionthree\sll.png" alt="Step 1.1" width="400"/> <br> 



# Fourth Session: Executing C Code to Print/Determine Prime Numbers Up to a Certain Limit Using the Sieve of Eratosthenes Algorithm 


In this lab, we are repeating the tasks from the first session, but with a different C code implementation.

# **Sieve of Eratosthenes**

The **Sieve of Eratosthenes** is a well-known algorithm with a predictable pattern of execution that heavily relies on memory access and bitwise operations. It is an ancient algorithm used to find all prime numbers up to a specified integer. It works by iteratively marking the multiples of each prime number starting from 2. The numbers that remain unmarked after all the multiples have been marked are prime. Comparing its performance on different architectures and compilers can reveal how well each handles large-scale, memory-intensive operations, and the efficiency of loop unrolling, bitwise optimizations, and cache utilization. 

**Key Aspects:**

* **Memory Allocation and Access**: The algorithm uses a dynamically allocated boolean array to mark non-prime numbers, which tests memory allocation and access patterns.

* **Bitwise Operations and Loops**: The core of the algorithm involves setting bits (marking non-primes) in a loop, testing how well the compiler optimizes such operations.


* **Time Complexity**: The algorithm is efficient but still requires significant computational effort for large limits (like 1,000,000), making it a good performance benchmark.



## 1. Over GCC

1.1 Refer to the C code saved in file *sieve.c*: 

```
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h> // Include this header for malloc and free
#include <math.h>

void sieve_of_eratosthenes(int limit) {
    // Allocate memory for the prime array
    bool *prime = (bool *)malloc((limit + 1) * sizeof(bool));
    if (prime == NULL) {
        printf("Memory allocation failed\n");
        return;
    }

    // Initialize all entries as true
    for (int i = 0; i <= limit; i++) {
        prime[i] = true;
    }

    prime[0] = prime[1] = false; // 0 and 1 are not primes

    for (int p = 2; p * p <= limit; p++) {
        if (prime[p]) {
            for (int i = p * p; i <= limit; i += p) {
                prime[i] = false;
            }
        }
    }

    // Print the prime numbers
    printf("Prime numbers up to %d are:\n", limit);
    for (int p = 2; p <= limit; p++) {
        if (prime[p]) {
            printf("%d ", p);
        }
    }
    printf("\n");

    // Free the allocated memory
    free(prime);
}

int main() {
    int limit;

    printf("Enter the limit up to which you want to find prime numbers: ");
    scanf("%d", &limit);

    if (limit<2) {
        printf("There are no prime numbers less than 2. \n");
    }   else {
        sieve_of_eratosthenes(limit);
    }
    return 0;
}
```
1.2 The output snapshot is pasted below: 

<img src="imagessessionfour\gccop.png" alt="Step 1.1" width="400"/> <br>  
 
***sieve_gcc.out*** is the name of the output file 

Note: The commands used are the same as of first session apart from the file names. 


## 2. Over RISCV GCC (O1 and Ofast) 


### 2.1 O1 Compiler Flag

**2.1.1** To compile using O1 compiler flag use the following command: 

``` 
riscv64-unknown-elf-gcc -O1 -mabi=lp64i -march=rv64i -o sieveO1 sieve.c
```

***sieveO1*** is the output file after compiler. This is accessed using the command:

``` 
spike pk sieve01
```


**2.1.2** The output is the same as GCC and the following: 

<img src="imagessessionfour\O1_op.png" alt="Step 1.1" width="400"/> <br> 


**2.1.3** To gather information about the number of instructions use the following command: 

```
riscv64-unknown-elf-objdump -d sieveO1
```

Again, navigate to the /main section and calculate the number of instructions as done in session two and the number of instructions can be inferred to be 21.

Refer to the snapshot below: 

<img src="imagessessionfour\01instructions.png" alt="Step 1.1" width="400"/> <br> 




### 2.2 Ofast Compiler Flag

**2.2.1** To compile using Ofast compiler flag use the following command: 

```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sieveOfast sieve.c
```

***sieveOfast*** is the output file after compilation.

**2.2.2** The output is again, the same as GCC and RISCV-GCC with O1 compiler flag. To access the output file using riscv emulator spike, use the command: 

```
spike pk sieveOfast
```



**2.2.3** Use the same step as above (for O1 flag) to gather information about the number of instructions. 

Refer to the snapshot below: 

<img src="imagessessionfour\Ofastinstructions.png" alt="Step 1.1" width="400"/> <br> 




The number of instructions are 21 again. 



# Fifth Session: Digital Logic with TL Verilog and Makerchip

## What is TL Verilog? 
**TL-Verilog** is a modern hardware description language designed to simplify and accelerate digital design by reducing the verbosity and complexity commonly associated with traditional hardware languages like Verilog and VHDL. TL-Verilog introduces a novel approach to design, emphasizing transactional-level modeling and making it easier to handle complex pipelined designs. With TL-Verilog, designers can focus more on the behavior of the hardware rather than low-level implementation details, thanks to features like automatic pipeline handling, clean and concise syntax, and built-in support for powerful abstraction mechanisms.

## Makerchip

Makerchip is an online platform and integrated development environment (IDE) designed to facilitate the design and simulation of digital circuits using TL-Verilog and traditional Verilog. It provides an accessible and user-friendly environment where users can write, simulate, and visualize their hardware designs directly in a web browser, without the need for installing any software.


## Developing a **Combinational Logic** for a Simple Calculator in TL Verilog using Makerchip


A basic calculator is implemented using a 4x1 multiplexer. It performs the following primitive calculations: 
   
1. ADD: ```$sum[31:0] = $val1[31:0] + $val2[31:0];```
2. SUB: ``$diff[31:0] = $val1[31:0] - $val2[31:0];``
3. QUOT: ``$quot[31:0] = $val1[31:0] / $val2[31:0];``
4. PROD: `$prod[31:0] = $val1[31:0] * $val2[31:0];`  

The above operations are implemented, as mentioned using a 4x1 MUX. The same can be implemented in TL Verilog using ternary operators. Take a look at the code below to do so: 


```
$out[31:0] = ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
         ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
         ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                          $quot;   // If sel is 11, select quot

```

The select signal and the operands for the calculators are chosen at random using the `` $random`` command. 

Have a look at the complete TL Verilog code for reference: 

```
$val1[31:0]  = $rand1[3:0];
   $val2[31:0] = $rand2[3:0];
   
   $sum[31:0] = $val1[31:0] + $val2[31:0];
   $diff[31:0] = $val1[31:0] - $val2[31:0];
   $prod[31:0] = $val1[31:0] * $val2[31:0];
   $quot[31:0] = $val1[31:0] / $val2[31:0];
   
   $sel[1:0] = $rand3[1:0];
    
   
   $out[31:0] = ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
         ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
         ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                          $quot;   // If sel is 11, select quot
```

The snapshot of the above activity is attached below:


<img src="imagessessionfive\calc_mux_1.png" alt="Step 1.1" width="400"/> <br> 

## Adding **Sequential Logic** to the Calculator 

Sequential Logic is implemented by using a clock signal. The signals produced at the offset of each clock might be of importance/use in the program which might need those values to perform operations on them. Therefore we use the ```>>(integer)$(operand_name)``` operator to access signals from clock signal which we require.

### Free Running Counter 
Firstly, we shall implement a Free Running Counter in TL Verilog using Makerchip.

The following code acts as a simple free running counter with a reset value of 0. The counter adds integer 1 to $num1 at each clock. This is done so in the following manner in TL Verilog: 

``` $num1[31:0] = $reset ? 0 : >>1$num1[31:0] + 1; ```

The value stored in $num1[31:0] is utilized using the operator mentioned above for a working model of a counter.

Refer to the snapshot below for reference: 

<img src="imagessessionfive\sq_logic_counter.png" alt="Step 1.1" width="400"/> <br> 

### Sequential Calculator 
As mentioned , the introduction of sequential logic will introduce the utilization of values which are obtained from clock cycles which are different from the ones where the operations are performed. This was seen in a simple manner in the previous example of a Free Running Counter as well. 


Moving on, our calculator is now modified to "hold" a value. This is done so, in the hardware, using a Flip-Flop. The value stored in the $out[31:0] is now fed to $val1[31:0] from our calculator example. 

This modification is done in the following manner: 

```$val1[31:0]  = >>1$out[31:0]; ```  

Therefore, the value in the output from the subsequent cycle is fed in as our new input. 

Practicallly speaking, calculators need a reset button as well, this will hold the output @ 0. The reset option is added into the 4x1 multiplexer code in the following manner: 
```
$out[31:0] = $reset ? 0 :($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
         ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
         ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                          $quot;   // If sel is 11, select quot
```
This can be inferred more clearly in the snapshot below: 

<img src="imagessessionfive\sq_calc_1.png" alt="Step 1.1" width="400"/> <br> 

From the snapshot, it can be seen that whenever the reset is HIGH, the output is set to 0. The calculator now performs all of it's regular defined operations, albeit now it has one of it's input taken from the output of the previous cycle. 

## Pipelined Logic 

In Verilog, pipelining is often implemented by designing a series of sequential stages where each stage is a separate module or a block of logic, and the stages are connected through registers. Each stage performs a part of the overall computation, and data moves from one stage to the next on each clock cycle.

### Assigning Counter and Calculator Developed in Previous Steps Into a Pipeline

As mentioned, pipelining is done so as to segregate operations or a block of logic which have some coherence or simply put, are associated with each together. In this example, **we shall put the Counter and the Calculator in a single pipeline and within a single pipeline stage as well.**

To initiate a pipeline, use the command: ``` |cacl ``` and make sure the indentation beyond this right.

To assign a pipelining stage to a set of operations, logic block or a module, use the command: ``` @int ```. This integer value depicts the pipelining stage with respect to the clock cycle. The calculator and the counter both, are added to this ``` |calc ``` pipeline in this following manner: 


```
|calc
      @1
             // Declare and initialize variables
         $reset[31:0] = *reset;

             // Generate random values and perform operations
         $val1[31:0] = >>1$out[31:0];
         $val2[31:0] = $rand2[3:0];

          // Perform arithmetic operations
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         $sel[1:0] = $rand3[1:0];

          // Update num1 and output based on selection

         $num1[31:0] = $reset ? 0 : >>1$num1[31:0] + 1;

         $out[31:0] = $reset ? 0 : ($sel == 2'b00) ? $sum  :  
                        ($sel == 2'b01) ? $diff :  
                        ($sel == 2'b10) ? $prod :  
                                         $quot;   

```
The waveforms and the corresponding figure generated is posted below for reference. 


<img src="imagessessionfive\pipeline1.png" alt="Step 1.1" width="400"/> <br>

### Cycle Calculator 

The code now is modified to use different stages of the pipeline. The 4x1 MUX is now pushed to the second stage while the following circuit is implemented: 

<img src="imagessessionfive\pipeline_ckt.png" alt="Step 1.1" width="400"/> <br>

Following is the modified code: 

```
|calc
      @1
             // Declare and initialize variables
         $reset = *reset;

             // Generate random values and perform operations
         $val1[31:0] = >>2$out[31:0];
         $val2[31:0] = $rand2[3:0];

          // Perform arithmetic operations
         $sum[31:0] = $val1[31:0] + $val2[31:0];
         $diff[31:0] = $val1[31:0] - $val2[31:0];
         $prod[31:0] = $val1[31:0] * $val2[31:0];
         $quot[31:0] = $val1[31:0] / $val2[31:0];
         $sel[1:0] = $rand3[1:0];

          // Update num1 and output based on selection

         $num1[31:0] = $reset ? 0 : >>1$num1 + 1;
      @2
         $valid = !$num1;
         $rst_alt = $valid | $reset;
         $out[31:0] = $rst_alt ? 32'b0 : ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
                        ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
                        ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                                         $quot;   // If sel is 11, select quot


```
This retiming of the 4x1 MUX to the second clock using ``` @2 ``` is done to ease timings. Functionally speaking, everything else remains the same. Snapshot pasted below for reference: 

<img src="imagessessionfive\pipeline2.png" alt="Step 1.1" width="400"/> <br>


## Validity 

In TL-Verilog, validity is a key concept used to manage data flow through pipelines. It helps ensure that operations are only performed on valid data and prevents the unnecessary processing of invalid or stale data. This concept is essential in pipelined designs, where operations are spread across multiple clock cycles.

### Cycle Calculator with Validity 


Moving on, some changes have been made according to the circuit below: 

<img src="imagessessionfive\validity2.png" alt="Step 1.1" width="400"/> <br>

The enable signal for the 4x1 MUX has now been 'checked' using a valid signal in the following manner: 

``` $rst_alt = $valid | $num1; ``` This is a when condition now for the calculation to occur. We have therefore introduced a condition onto the operations of our calculator. Only if the condition is valid, will the calculator do it's task. This is encoded in the Multiplexer behaviour as an enable signal.
The multiplexer behaviour is also modified in accordance to this in the following manner: 
``` $out[31:0] = $rst_alt ? 32'b0 : ($sel == 2'b00) ? $sum  :  // If sel is 00, select sum
                        ($sel == 2'b01) ? $diff :  // If sel is 01, select diff
                        ($sel == 2'b10) ? $prod :  // If sel is 10, select prod
                                         $quot;   // If sel is 11, select quot
```

Refer to the snapshot below with waveforms to verify the behaviour:

<img src="imagessessionfive\validity1.png" alt="Step 1.1" width="400"/> <br>

# Sixth Session:  Basic RISC-V CPU Micro-architecture 

The block diagram below vaguely represents the RISC-V CPU along with it's components: 

<img src="imagessessionfive\block.png" alt="Step 1.1" width="400"/> <br>

1. **Program Counter**: The Program Counter (PC) is a critical component in a RISC-V CPU (and any CPU in general), responsible for keeping track of the address of the next instruction to be executed. Understanding the role and implementation of the PC is fundamental when designing or working with a RISC-V CPU.
2. **Instruction Fetch**: Instruction fetch is the first stage in the instruction execution cycle of a RISC-V CPU. It involves retrieving the instruction pointed to by the Program Counter (PC) from memory so that it can be decoded and executed in subsequent stages.
3. **Instruction Decode**: Instruction decode is the second stage in the instruction execution cycle of a RISC-V CPU. After an instruction is fetched from memory, it needs to be interpreted, or "decoded," to understand what operation is to be performed and which operands are involved. The decoding process involves breaking down the binary instruction into its constituent fields, such as opcode, source registers, destination registers, and immediate values.
4. **Register File Read**: The read register file is a component that contains a collection of registers used to store data during instruction execution. Instructions typically involve accessing data from these registers, with the instruction indicating which registers to read. The retrieved data is then used as operands for operations carried out by the ALU or other CPU components.
5. **Register File Write**: In a RISC-V CPU, the register file write operation is a critical part of the instruction execution process, particularly during the write-back stage of the pipeline. This is where the results of computations or data from memory are written back to a register in the register file
6. **ALU**: The Arithmetic Logic Unit (ALU) in a RISC-V CPU is a key component responsible for performing arithmetic and logical operations. The ALU receives inputs from the register file or immediate values from instructions and produces results that are either stored back into registers, used for branching decisions, or forwarded to other components like memory.
7. **Data Memory**: n a RISC-V CPU, data memory is a crucial component that stores and retrieves data required during program execution. Data memory is involved in load and store operations, where data is either read from or written to memory.

## Fetch and Decode

### Program Counter
The program counter is implemented according to the condition specified in the lab as follows: 
`` $reset = *reset;
         $pc[31:0] = >>1$reset ? 0 : >>1$pc + 32'd4; 
``
The snapshot containing the waveform is pasted below: 

<img src="imagessessionfive\pc.png" alt="Step 1.1" width="400"/> <br>

### Instruction Fetch 

The fetch code is shifted to the second cycle ```@1``` and the code is given below: 
```
@1 
         $imem_rd_en = !$reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $inst[31:0] = $imem_rd_data[31:0]; 
```
Observe the snapshot for inference purpose.

<img src="imagessessionfive\instructionfetch.png" alt="Step 1.1" width="400"/> <br>

### Instruction Decode

### Instruction Type Decode Logic
The code to decode the instruction type from $instr[6:2] is the following: 
```
$is_i_instr = $instr[6:2] ==? 5'b0000x ||
              $instr[6:2] ==? 5'b001x0 ||
              $instr[6:2] ==? 5'b11001;
                       
         
$is_u_instr = $instr[6:2] ==? 5'b0x101;
         
$is_r_instr =   $instr[6:2] ==? 5'b01011 ||
                $instr[6:2] ==? 5'b011x0 ||
                $instr[6:2] ==? 5'b10100;
         
$is_b_instr = $instr[6:2] ==? 5'b11000;
         
$is_j_instr = $instr[6:2] ==? 5'b11011;
         
$is_s_instr = $instr[6:2] ==? 5'b0100x;
```

The above code checks the instruction type from I,U,R,B,J,S. The snapshot is attached below: 

<img src="imagessessionfive\decode1.png" alt="Step 1.1" width="400"/> <br>

### Instruction Immediate Decode Logic 

Find the code below for immediate decode logic:

```
$imm[31:0] = $is_i_instr ? {{21{$inst[31]}}, $inst[30:20]} :
                      $is_s_instr ? {{21{$inst[31]}}, $inst[30:25], $inst[11:8], $inst[7]} :
                      $is_b_instr ? {{20{$inst[31]}}, $inst[7], $inst[30:25], $inst[11:8], 1'b0} :
                      $is_u_instr ? {$inst[31], $inst[30:20], $inst[19:12], 12'b0} :
                      $is_j_instr ? {{12{$inst[31]}}, $inst[19:12], $inst[20], $inst[30:21], 1'b0} :
                                    32'b0;
```

The snapshot which contains the waveforms is given below: 

<img src="imagessessionfive\instr_decode.png" alt="Step 1.1" width="400"/> <br>

### Extracting Other Instruction Fields based on Instruction Type

Find the code to infer other sub-instructions in the $inst stream.
```
$rs1_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_use
            $rs1[4:0] = $inst[19:15];
         
         $rs2_use = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_use
            $rs2[4:0] = $inst[24:20];
            
         $funct3_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_use
            $funct3[2:0] = $inst[14:12];
            
         $funct7_use = $is_r_instr ;
         ?$funct7_use
            $funct7[6:0] = $inst[31:25];
            
         $rd_use = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_use
            $rd[4:0] = $inst[11:7];
         
         $opcode[6:0] = $inst;
```
Refer to the waveform below, which is too big to capture within a single frame: 

<img src="imagessessionfive\deocde3.png" alt="Step 1.1" width="400"/> <br>

### Decoding Individual Instruction 

Find the code below to do so: 

```
 $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         
```
The signals defined for each individual instructions can be seen in the waveform below: 

<img src="imagessessionfive\individual_decode.png" alt="Step 1.1" width="400"/> <br>

## RISCV Control Logic 

### Register File Read 

Refer to the 2-Read, 1-Write Register File below for reference.

<img src="imagessessionfive\registerfile.png" alt="Step 1.1" width="400"/> <br>

The code for register file read is adder to ` @1 ` as follows: 

```
$rf_rd_en1 = $rs1_use;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_use;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
```
Where the register output for corresponding ` $rs1 ` and ` $rs2 ` are added in ``` $src1_value[31:0] ``` and ``` $src2_value[31:0]. ```

**NOTE**:  The macro ``` m4+rf(@1, @1) ``` defines the register file that we have used above. This register file is capable of performing two reads in a cycle and based on that, provides the corresponding output in the data lines mentioned. 

### ALU Operations for ADD/ADDI 

As mentioned in the lab, the ALU code is provided below: 

```
$result[31:0] = $is_addi ? $src1_value + $imm :
                $is_add ? $src1_value + $src2_value :
                32'bx ;
```

### Register File Write 

For register file write, we need an overhead logic which enables the write operation. It is embedded in the code below: 

```
 $rf_wr_en = $rd_use;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $rd == 0 ? 0 : $result;
```

### Implementing Branch Instructions 

We have the enable signals for each type of instructions coded. These 1 bit signals act as enable signals for implementing the code for branch signals. Find the code below: 

```
$taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         $br_tgt_pc[31:0] = $pc + $imm;
```

### Testbench 

Simple testbench to access the register used in our calculation: 

```
*passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
```
### NOTE 
To incorporate the validity and the use of branch instructions in the program counter, edit the 'pc' code as follows: 

```
$pc[31:0] = >>1$reset ? 1'b0 : >>1$taken_branch ? >>1$br_tgt_pc : >>1$pc + 32'd4;
         
```



The log file snapshot is pasted below: 

<img src="imagessessionfive\logfile.png" alt="Step 1.1" width="400"/> <br>


**The overall diagram now looks as following**:

<img src="imagessessionfive\figure_latest.png" alt="Step 1.1" width="400"/> <br>

**The overall code is as following**:

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      
      
      @0
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 1'b0 : >>1$taken_branch ? >>1$br_tgt_pc : >>1$pc + 32'd4;
         
      @1 
         $imem_rd_en = !$reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $inst[31:0] = $imem_rd_data[31:0]; 
         
         $is_i_instr = $inst[6:2] ==? 5'b0000x ||
                       $inst[6:2] ==? 5'b001x0 ||
                       $inst[6:2] ==? 5'b11001;
                       
         
         $is_u_instr = $inst[6:2] ==? 5'b0x101;
         
         $is_r_instr = $inst[6:2] ==? 5'b01011 ||
                       $inst[6:2] ==? 5'b011x0 ||
                       $inst[6:2] ==? 5'b10100;
         
         $is_b_instr = $inst[6:2] ==? 5'b11000;
         
         $is_j_instr = $inst[6:2] ==? 5'b11011;
         
         $is_s_instr = $inst[6:2] ==? 5'b0100x;
         
         
         $imm[31:0] = $is_i_instr ? {{21{$inst[31]}}, $inst[30:20]} :
                      $is_s_instr ? {{21{$inst[31]}}, $inst[30:25], $inst[11:8], $inst[7]} :
                      $is_b_instr ? {{20{$inst[31]}}, $inst[7], $inst[30:25], $inst[11:8], 1'b0} :
                      $is_u_instr ? {$inst[31], $inst[30:20], $inst[19:12], 12'b0} :
                      $is_j_instr ? {{12{$inst[31]}}, $inst[19:12], $inst[20], $inst[30:21], 1'b0} :
                                    32'b0;
         
         $rs1_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_use
            $rs1[4:0] = $inst[19:15];
         
         $rs2_use = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_use
            $rs2[4:0] = $inst[24:20];
            
         $funct3_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_use
            $funct3[2:0] = $inst[14:12];
            
         $funct7_use = $is_r_instr ;
         ?$funct7_use
            $funct7[6:0] = $inst[31:25];
            
         $rd_use = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_use
            $rd[4:0] = $inst[11:7];
         
         $opcode[6:0] = $inst;
         
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         //Register Read 
         $rf_rd_en1 = $rs1_use;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_use;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
       
         
         //ALU
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //Register File Write 
         
         $rf_wr_en = $rd_use;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $rd == 0 ? 0 : $result;
         
         //Branch Instructions
         
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         $br_tgt_pc[31:0] = $pc + $imm;
         
         //Testbench
         *passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
      // YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```

The individual labs are commented to better navigate through the code.

# Seventh Session: Complete Pipelined RISC-V CPU Microarchitecture


## Valid Signal

To find valid signals for the program counter to execute and point, introduce a `` $start `` and a new `` $valid `` signal as following:

```
$start = >>1$reset && !$reset;
$valid = $reset ? 1'b0 : ($start || >>3$valid);

```

Moreover, a new valid branch signal is assigned as follows: 

```
$valid_taken_br = $valid && $taken_branch;
```

The next thing to do is to incorporate this into the program counter assignment as follows: 

```
$pc[31:0] = >>1$reset ? 1'b0 : >>3$valid_taken_branch ? >>3$br_tgt_pc : >>1$pc + 32'd4;
```

## Branch Target Path 

The `$valid`, `$valid_load` and `$valid_jump` signals need to be defined and incorporated in the `$valid` signal now in `@1`.

```
$valid = !(>>1$valid_taken_branch || >>2$valid_taken_branch || >>1$valid_load || >>2$valid_load 
                    || >>1$valid_jump || >>2$valid_jump) ;
                    
         $valid_load = $valid && $is_load ;
         $valid_jump = $valid && $is_load;
      


```

Moving on, more instruction signals are added to the code. They are: 

```
$is_load = $dec_bits ==? 11'bx_xxx_0000011;
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_lui = $dec_bits ==? 11'bx_xxx_0110111;
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr = $dec_bits ==? 11'bx_000_1100111;
         $is_jump = $is_jal || $is_jalr ;
```

## Updating Register Read 

Register Read is updated as follows: 

```
$rf_rd_en1 = $rs1_use && >>2$result;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_use && >>2$result;
         $rf_rd_index2[4:0] = $rs2;
```
## Data Memory 

```
$dmem_wr_en = $is_s_instr && $valid ;
         $dmem_addr[3:0] = $result[5:2] ;
         $dmem_wr_data[31:0] = $src2_value ;
         $dmem_rd_en = $is_load ;
```

## Load Data

```
$ld_data[31:0] = $dmem_rd_data ;

```

## Adding Instruction Signals and their definitions to $result in ALU 

```
$result[31:0] = $is_addi ? $src1_value + $imm :
              $is_add ? $src1_value + $src2_value :
              $is_andi ? $src1_value & $imm :
              $is_ori  ? $src1_value | $imm :
              $is_xori ? $src1_value ^ $imm :
              $is_slli ? $src1_value << $imm[5:0] :
              $is_srli ? $src1_value >> $imm[5:0] :
              $is_and ? $src1_value & $src2_value :
              $is_or ? $src1_value | $src2_value :
              $is_xor ? $src1_value ^ $src2_value :
              $is_sub ? $src1_value - $src2_value :
              $is_sll ? $src1_value << $src2_value[4:0] :
              $is_srl ? $src1_value >> $src2_value[4:0] :
              $is_sltu ? $src1_value < $src2_value :
              $is_sltiu ? $src1_value < $imm :
              $is_lui ? {$imm[31:12], 12'b0} :
              $is_auipc ? $pc + $imm : 
              $is_jal ? $pc + 32'd4 :
              $is_jalr ? $pc + 32'd4 :
              $is_srai ? {{32{$src1_value[31]}}, $src1_value} >> $imm[4:0] :
              $is_slt ? ($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]} :
              $is_slti ? ($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]} :
              $is_sra ? {{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0] :
              $is_load || $is_s_instr ? $src1_value + $imm :
              32'bx ;
      @3
         //Register File Write 
         
         $rf_wr_en = $rd_use && $rd != 5'b0 && $valid || >>2$valid_load;
         $rf_wr_index[4:0] = >>2$valid_load ? >>2$rd : $rd;
         $rf_wr_data[31:0] = >>2$valid_load ? >>2$ld_data :  $result;
         
         //Branch Instructions
         
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;

```
### Note: Change the MACROS again as follows:

```
|cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
```


## Final RISCV Diagram

The final diagram comes out to be: 


<img src="imagessessionfive\final_figure.png" alt="Step 1.1" width="400"/> <br>


## Final Waveforms
### Waveforms containing *clk_arn* i.e. personalized clock name.
<img src="imagessessionfive\waveform_1.png" alt="Step 1.1" width="400"/> <br>

### Waveform containig reset signal. 

<img src="imagessessionfive\waveform_2.png" alt="Step 1.1" width="400"/> <br>

### Waveform containing contents in xreg14 for each cycle.

<img src="imagessessionfive\waveform_3.png" alt="Step 1.1" width="400"/> <br>

## Note: The final code is uploaded in this repository as *riscv.tlv*.


# Session Eight: Converting riscv.tlv Code to Verilog Code

 We are now converting our TLV code in the file riscv.tlv to verilog code using Python's Sandpiper-SaaS library.

After converting the TLV code to Verilog, we will write a Verilog testbench. We will then compare the waveforms generated from the MakerChip platform with those obtained from the Verilog code output.

Therefore, to do the above task follow the given steps:

## Create a python Virtual Environment

As the name suggests, use the following command to create a virtual environment:

```
python -m venv .venv 

```
## Download sandpiper-saas python module

Use the following command to do so: 

```
pip3 install sandpiper-saas

```

Now once the virtual environment is created and the sandpiper module is installed using the previous commands, use the command below that will undergo conversion:

```
sandpiper-saas -i ./tlv_code/cpu.tlv -o RV_CPU.v --bestsv --noline -p verilog --outdir ./src/module/

```
This command takes our previously written TLV code which is now stored in cpu.tlv for this lab's purpose.


## Testbench & iverilog 


Testbench is written which contains a clock signal of 5ps i.e. 1 GHz. At 25ps we are setting the reset signal to HIGH and after a while we set this LOW. When this state is reached, our CPU starts to perform the tasks which it is supposed to perform. 

Use iverilog which was installed in previous labs to compile this converted TLV code using the testbench we wrote. The following command does that: 

```
iverilog -o output/RV_CPU.out src/module/cpu_tb.v -I src/include -I src/module
```

Note that we have stored our testbench named cpu_tb.v in the module folder. This command will generate an 'out' file.

## Using gtkwave 

gtkwave was installed in the previous labs for the purpose of waveform visualization. The 'out' file which was generated is given as an input to the command line prompt which is as follows: 

```
./RV_CPU.out
gtkwave RV_CPU_tb.vcd
```

## Required Results 

Consider the makerchip waveforms which were generated in the previous lab: 

### Waveforms containing *clk_arn* i.e. personalized clock name.
<img src="imagessessionfive\waveform_1.png" alt="Step 1.1" width="400"/> <br>

### Waveform containig reset signal. 

<img src="imagessessionfive\waveform_2.png" alt="Step 1.1" width="400"/> <br>

### Waveform containing contents in xreg14 for each cycle.

<img src="imagessessionfive\waveform_3.png" alt="Step 1.1" width="400"/> <br>

## GTK Waveform for this lab.

<img src="imagesssessionsix/gtk_waveform.png" alt="Step 1.1" width="400"/> <br>

Therefore, the final result of 2D is visible in the waveform output produced by gtkwave.

# Session Eight: Installing Required Tools and Using BabySoC 


## Yosys
Firstly, we need to install Yosys. To do that follow the given commands/steps.

1.  Clone the repository to your local PC using:  
    
    `git clone https://github.com/YosysHQ/yosys.git`
    
    
2. Go to the Yosys directory: 
        
    `cd yosys`
    
3.  Further steps: 
    ```
        $ sudo apt install make (If make is not installed) 
       
        $ sudo apt-get install build-essential clang bison flex \
        libreadline-dev gawk tcl-dev libffi-dev git \
        graphviz xdot pkg-config python3 libboost-system-dev \
        libboost-python-dev libboost-filesystem-dev zlib1g-dev
       
        $ make config-gcc
       
        $ make 
       
        $ sudo make install
    ```
    

    Note: The above commands are specified beforehand and the tools above are required for this lab.


## iverilog 


Iverilog is an open-source Verilog simulation and synthesis tool that allows you to compile and simulate Verilog HDL (Hardware Description Language) designs. It's commonly used in digital design and verification to test the functionality of hardware models before implementing them on actual hardware like FPGAs or ASICs.

Use the following command to install: 

`     sudo apt-get install iverilog ` 


## gtkwave

GTKWave is an open-source waveform viewer used to analyze the simulation output of digital circuits, typically generated by simulation tools like Icarus Verilog (Iverilog). It is widely used in hardware design and verification to visualize and debug the behavior of digital systems described in Verilog, VHDL, or other hardware description languages. 

Use the following command to install: 

`  sudo apt install gtkwave ` 

## openSTA

1. Use the following commands to checkout the git repository and build the OpenSTA library and excutable.

```
git clone https://github.com/parallaxsw/OpenSTA.git
cd OpenSTA
mkdir build
cd build
cmake ..
make

```

Refer to this repository for more information: 

```
https://github.com/The-OpenROAD-Project/OpenSTA

```

Before we proceed, add the following files from BabySoc repository:

1. src/module : 'avsddac.v', 'avsdpll.v', 'clk_gate', 'pseudo_rand.sv', 'pseudo_rand_gen.sv', 'vsdbabysoc.v'

Link for the repository mentioned: 
```
https://github.com/Subhasis-Sahu/BabySoC_Simulation

```

## Simulation 

1. ` iverilog -o output/RV_CPU.out src/module/cpu_tb.v -I src/include -I src/module `


    Note: This is only for reference. Your testbench would be named differently.

2. Go to the output directory and run 

    ` ./RV_CPU.out `

3. The dump file is generated with the name: ` RV_CPU_tb.vcd`

    Use the command:  ` gtkwave RV_CPU_tb.vcd ` 

The above command shall initiate a GUI where you can access the following waveforms: 

 * REF : clock reference input signal to the PLL module.
 * clk 
 * clk_arn 
 * reset 
 * out 
 * OUT

Note: The signals 'REF', 'clk', 'clk_arn', 'reset', 'out' are taken from `core` in gtkwave, while 'OUT' is the `DAC` module output signal.

## Final Screenshot

<img src="imagessessionseven\asic_babysoc.png" alt="Step 1.1" width="400"/> <br>

The screenshot above depicts the required/predicted waveform with the '2D' hex output which is the sum from 1 to 9.


# Session 9
# Introduction To Verilog RTL Design and Synthesis

## Simulator? 

* RTL Design is checked for adherence to the specs by simulating the design.
* The tool used for simulating the design is the simulator.
* We have used iverilog for our lab.
* Looks for the changes in the input changes and evaluates the output based on changes in the input signal. 
* i.e. the simulator will not evaluate the output if there is no change in the input

## Design? 
* Actual verilog code or set of verilog codes which has the intended functionality to meet the required specifications. 

## Testbench?

* Setup to apply stimulus to the design to check it's functionality.
****
## Design and Testbench Setup 

* The design under test or 'dut' is actually instantiated within the testbench keeping in mind the ports which are part of it.
* The stimulus is generated in the verilog code for the testbench. 
* The testbench does not have any input or output ports to it.

<img src="session_nine\design_tb.png" alt="Step 1.1" width="400"/> <br>


## iVerilog based Simulation Flow

* You provide the actual design code and the testbench for that design to iverilog and it look for stimulus in the testbench and 'test' that on the actual design.
* Also, the output of the simulator is the 'vcd' file (acronym for 'Value Change Dump').
* To view the waveforms in the dump file, we use gtkwave to verify the functionality of the design.

<img src="session_nine\gtkwave_week9.png" alt="Step 1.1" width="400"/> <br>

## Introductory Lab

To prepare for the upcoming labs, we need to have the necessary files and setup.

* Create a directory VLSI using 

````
mkdir VLSI 
````
* Go to the directory --> 
````
cd VLSI 
````

* Clone the skywater130RTLDes repository --> 

````
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git 
````



This snapshot has all the commands.

<img src="session_nine\gitclone_week9.png" alt="Step 1.1" width="400"/> <br>


The My_Lib folder contains files required for the labs. More importantly, the verilog_files folder contains all the design files and the testbenches which will be used in the labs. The snapshop below contains the files which are present in the verilog_files folder.

<img src="session_nine\verilogfiles_week9.png" alt="Step 1.1" width="400"/> <br>


## Introduction to iverilog & GTKWave 

In this lab we shall look into how do we go about using the iverilog simulator for a 2x1 Mux. 

* We begin with the design for the mux provided in the verilog_files folder along with the testbench.

* We use the command 'iverilog good_mux.v tb_good_mux.v' to simulate the design using the testbench.

* The snapshot below contains both, the commands for simulating and consequently creating the dump file and viewing it.

<img src="session_nine\mux_week9.png" alt="Step 1.1" width="400"/> <br>


* The Gtkwave output is as follows:

<img src="session_nine\gtkwave_mux.png" alt="Step 1.1" width="400"/> <br>


* You can also view the contents of the file using 'vim'. If you haven't, you should install it if you haven't using the command 'sudo apt install vim' on your linux machine.

* Use the command ``` vim tb_good_mux.v -o good_mux.v ``` to do so. This is what it looks like: 

<img src="session_nine\contents_week9.png" alt="Step 1.1" width="400"/> <br>


## Introduction to Yosys and Logic Synthesis

### Synthesizer?

* Tool used for converting the RTL to Netlist. 
* We have used Yosys before and shall be using it moving on for this purpose.
* We have a design and a .lib which we apply to Yosys which provides us with the Netlist. 
* We have the command read_verilog to read the file and command read_liberty command to read the .lib.
* You also have the write_verilog command to write the netlist which is generated by Yosys.

* The netlist is the representation of our design in the form of standard cells which we have exported from the repository we earlier cloned. The cells are present in the .lib.

* Snapshot for the whole worfklow explained below:

 <img src="session_nine\yosys_week9.png" alt="Step 1.1" width="400"/> <br>


### Verifying the Synthesis? 

* This process is similar to synthesizing the design, instead of the design file, we now have the netlist available to us with the standard cells. 
* You provide this netlist and the testbench to iverilog and it in turns produces the vcd file described earlier.
* This file is fed into gtkwave to view the waveforms to infer. 
* NOTE: The stimulus should be the same as that for the design file and the outputs observed should be the same as that observed during RTL simulation.
* The netlist is a true representation of the design and the primary inputs and outputs haven't changed from the RTL code. THerefore, the same testbench can be used.

* Snapshot better explains the above points

<img src="session_nine\verify_synthesis_week9.png" alt="Step 1.1" width="400"/> <br>

## Logic Synthesis

### RTL Design?

* Behavioral representation of the required specification in a HDL. 

### Synthesis 

* RTL to Gate-level translation.
* Design is converted into gates and the connections are made between the gates which is given out as file called netlist. 
* This is done so using .lib
* .lib is a collection of logical modules and includes basic logic gates including AND, OR, NOT, etc.

## Constraints for Setup and Hold

* Refer to the image: 

<img src="session_nine\setup_week9.png" alt="Step 1.1" width="400"/> <br>

* There is a constraint on the clock frequency limited by logic delay corresponding to the flip-flop, the setup constraint which requires the date to be present for a particular amount of time at the capture flip-flop and the combinational delay introduced by the circuit in between the flip-flops. 
* Ideally we want the combinational delay to be small and therefore arises the need for having 'faster cells'.

* Although the HOLD constraint limits the speed of the combinational logic since the data needs to be held for a particular amount of time after the clock edge before it is acted upon. The combinational circuit present shouldn't be too fast as to violate that. 

* This presents the need for having slower cells too along with faster cells. Hence we need a variety of cells to meet these requirements. These cells are present in the .lib.

## A bit of theory behind faster cells and slower cells

* A load in digital logic circuit is represented through a capacitor. Faster the discharging/charging of capacitance, lesser is the cell delay.
* For faster response, the transistors should be capable of sourcing more current. 
* Wider transistors lead to low delay but consumer more power and occupy large area.
* Narrow transistors have higher delay but are efficient in terms of area and power,
* i.e. faster cells come at the cost of area and power.



## Lab Using Yosys (good_mux)

Invoke Yosys using the command `` yosys ``. 

Following is the output: 

<img src="session_nine\yosys_Command_ss.png" alt="Step 1.1" width="400"/> <br>




As mentioned before, in the yosys flow, the first thing to do is to read the library. We do that by using the command ` read_liberty -lib ../sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib `

The next thing to do in the yosys flow is to read the verilog file using the command ` read_verilog verilog_files/good_mux.v `. Here we are using the good_mux design.

Use the command `` synth -top good_mux `` to synthesize the design.

Now, we have to generate the netlist using the command `` abc -liberty ./my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.``.


* The logic of good_mux is synthesized in terms of the standard cells which are available in the above library which we have used.
* i.e. we have specified the library file using the '' abc '' command.
* It also provides us with the report of what it has inferred. 

* Take a look at the report: 

<img src="session_nine\yosys_synth_report.png" alt="Step 1.1" width="400"/> <br>



The command to see the logic it has realised is 'show`. This shows the graphical version of the logic. Refer to the snapshot to see it: 

<img src="session_nine\show.png" alt="Step 1.1" width="400"/> <br>

To dump the verilog code for the netlist, use the command 

```
write_verilog -noattr verilog_files/good_mux_netlist.v

```

# Session 10
# Timing libs, hierarchical vs flat synthesis, efficient flop coding styles


## Introduction to timings .lib 


Again, .lib is a library that is the collection of standard cells, gates of different flavours, etc.
Every .lib file will provide

* timing 
* power 
* noise 
* area 

information for a single PVT (Process, VOltage, Temperature).
* Process variations due to fabrication.
* Voltage variations incur changes in the behaviour of the circuit.
* Temperature Sensitivity of semiconductor often plays an important role as well.

Libraries are characterized to model these variations.


The command to open the lib file is 

```
vim ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 

```
Decoding the name of the lib file.

* tt --> typical

* 0256 --> temperature

* 1v80 --> voltage

* hd --> high density

* sc --> standard cells

* fd --> skywater fab

* sky130 --> process name

Below is the snapshot of the lib file.

<img src="session_10\lib_contents.png" alt="Step 1.1" width="400"/> <br>

The .lib file contains library file, cells, pin informations.


## Hierarchical Synthesis vs Flat Synthesis

Invoke yosys using command `` yosys ``

Read the liberty file which is the sky130 library using the command 

```
read_liberty -lib ../sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

```
Read the verilog multiple_modules.v using the command

` read_verilog multiple_modules.v`

Use the command `synth -top multiple_module.v`

Look at the report:


The command `` abc -liberty ./my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.``.

Use the show command as `` show multiple_module ``

This is the output:

<img src="session_10\show.png" alt="Step 1.1" width="400"/> <br>


The above is the '' hierarchical design.'' 

Write the design and this will create a netlist using
```
write_verilog -noattr verilog_files/multiple_modules_hier.v
```

The FLAT synthesis merges all hierarchical modules present in the design into a single module to create a flat netlist.

Use the command `` flatten `` to flatten the netlist

Write the netlist using `` write_verilog `` command.

The logic realization is shown below.


<img src="session_10\flatten_synthesis_ouput.png" alt="Step 1.1" width="400"/> <br>

The syntheis hereby is 'flattened'.



Note: The same steps we followed for hierarchical synthesis are followed here too.


We do sub-module level synthesis for two reasons: 
* When we have multiple modules instnatiated in a design
* We follow the divide and conquer strategy

The command ` synth -top module_name.v ` which we used previously controls which modules needs to be synthesized.

The report for the first step is attached below:

<img src="session_10\report.png" alt="Step 1.1" width="400"/> <br>


## Various Flop Coding Styles and Optimization


## The need for flops
For any combinational circuit, the output is going to change after the propagation delay and the output glitches due to it.

To avoid these glitches we use a storage element i.e. a flop. The flop therefore makes the output stable. 


There exist a need to initialise the flop and for that matter we have control pins (set/reset) on the flop.


### Various Flop Coding Styles
* Asynchronous Reset: Upon reset signal, the q value will be set to 0.
* Asynchronous Set: Upon the set signal, the q value is set to 1
* Synchronous Reset: Upon the clock signal, if there exists a reset signal, the q value is set to 0.
* Synchronous Set: Upon clock signal, the q value is set to 1 if there exists a set signal before it.

### Snapshots 


### Asychronous Reset Design

First look, at the '' dff_asyncres.v '' design using the command

```
iverilog dff_asyncres.v tb_dff_asyncres.v

```

Use './a.out' and pull the vcd file up on github.


Here is the snapshot: 

<img src="session_10\dff_async_res.png" alt="Step 1.1" width="400"/> <br>



### Asychronous Set Design

<img src="session_10\async_set.png" alt="Step 1.1" width="400"/> <br>

### Synchronous Reset Design

<img src="session_10\sync_reset.png" alt="Step 1.1" width="400"/> <br>


## Synthesizing the Previous Three Circuits Using Yosys

For this, you need to explicitly tell the tool where to pick the design from in the -lib command.


### Asynchronous Reset

The same Yosys flow is followed as before for the Yosys synthesis

Snapshot for 'show' command

<img src="session_10\show_async_res.png" alt="Step 1.1" width="400"/> <br>

### Asynchronous Set

Similarly, for asynchronous set

<img src="session_10\show_async_set.png" alt="Step 1.1" width="400"/> <br>


### Synchronous Reset 

<img src="session_10\show_sync_res.png" alt="Step 1.1" width="400"/> <br>


## Optimizations

Considering the mult_2.v design file. We do not expect any hardware from this.


Observe the report: 

<img src="session_10\report.png" alt="Step 1.1" width="400"/> <br>


# Session Eleven
# Combinational and Sequential Optimization

## Combinational Logic Optimization

To squeeze the logic to get the most optimized design to achieve 
* Area and Power Savings 

Techniques used for optimization

* Constant Propagation
* Boolean Logic Optimization

## Sequential Logic Optimization 

* Techniques: 
1. Basic 

    1.1 Sequential Constant Propagation

2. Advanced

    2.1 State Optimization

    2.2 Retiming

    2.3 Sequential Logic Cloning

## Optimization on opt_check.v, opt_check2.v Design files


### opt_check.v

Invoke the yosys flow similar to what was done in the previous labs.

After the top -synth command run the optimization command

```
opt_clean -purge

```

Link it to the liberty file using the abc command.


Here is the snapshot of the show command output.

<img src="session11\optcheck_Show.png" alt="Step 1.1" width="400"/> <br>


### opt_check2.v

Follow the same steps as the above.

Snapshot:

<img src="session11\opt_check2_show.png" alt="Step 1.1" width="400"/> <br>


### opt_check3.v

Snapshot:

<img src="session11\opt3_show.png" alt="Step 1.1" width="400"/> <br>



### opt_check4.v

Snapshot:

<img src="session11\opt4_show.png" alt="Step 1.1" width="400"/> <br>


## Sequential Logic Optimizations

iverilog simulation for the design file 'dff_const1.v' using the command 'iverilog'.

Here is the gtkwave output: 

<img src="session11\const1_gtkwave.png" alt="Step 1.1" width="400"/> <br>


 q here is waiting for the edge of the clock and therefore you need a flop in the picture.


### Doing the same for dff_const2.v

Snapshot: 

<img src="session11\const2_gtkwave.png" alt="Step 1.1" width="400"/> <br>

### Doing the same for dff_const3.v


<img src="session11\const3_gtkwave.png" alt="Step 1.1" width="400"/> <br>




Here, q is always 1 in contrary to the previous design where we have to wait for the clock.

### Synthesizing the design using Yosys for dff_const1.v

Follow the Yosys flow again AND use the dfflibmap switch.

Here is the output of the show command:

<img src="session11\const1_show.png" alt="Step 1.1" width="400"/> <br>


### Synthesizing the design using Yosys for dff_const2.v

Looking at the report snapshot below, the tool has not inferred a flop or any cell for that matter:

<img src="session11\const2_report.png" alt="Step 1.1" width="400"/> <br>

Sequential optimized circuit using the show command:

<img src="session11\show_const2.png" alt="Step 1.1" width="400"/> <br>

### Synthesizing the design using Yosys for dff_const3.v

<img src="session11\const3_show.png" alt="Step 1.1" width="400"/> <br>


### Synthesizing the design using Yosys for dff_const4.v

<img src="session11\show_const4_show.png" alt="Step 1.1" width="400"/> <br>



### Simulating the const3 design

Simulate the const3 design again and take a look at the gtkwave output waveform.

<img src="session11\const3_gtkwave.png" alt="Step 1.1" width="400"/> <br>

Note: The synthesis output is shown in the section above.

In the previous case we didn't see that the sky130 has been inferred here in this case.

### Const4 Design

<img src="session11\show_const4_show.png" alt="Step 1.1" width="400"/> <br>


### Const5 Design 

<img src="session11\const5_show_NEW.png" alt="Step 1.1" width="400"/> <br>

## Sequential Optimization Unused Output

Unused Output Optimization refers to strategies and techniques aimed at reducing or eliminating unnecessary or redundant output in processes, systems, or designs. This concept is applied across various fields, including software development, manufacturing, energy management, and data processing.


### Synthesizing the counter_opt.v Design

Upon looking at the report, it will infer only 1 flipflop.


<img src="session11\counter_report.png" alt="Step 1.1" width="400"/> <br>


Upon the synthesis using the abc command, the output is 

<img src="session11\counter_show.png" alt="Step 1.1" width="400"/> <br>
counter_show

#### Optimized Design

<img src="session11\opt_count.png" alt="Step 1.1" width="400"/> <br>


# Session Twelve
# GLS, Blocking v/s Non-Blocking and Synthesis-Simulation Mismatch


<img src="session12\gls.png" alt="Step 1.1" width="400"/> <br>



## What is GLS?

Running the test bench with Netlist as DUT. 

Netlist is logically same as RTL Code i.e. same test bench will align with the design.


## Why GLS?

Verify the logical correctness of design after synthesis.

Ensuring the timing of the design is met. For this GLS needs to be run with delay annotations.

If the gate level models are delay annotated then we can use GLS for timing validation.

## Reasons for Synthesis Simulation Mismatch

* Missing sensitivity list
* Blocking vs Non-blocking assignments
* Non Standard Verilog Coding

### ternary_operator_mux.v Design File

The gtkwave waveform for the above file is

<img src="session12\ternary_gtkwave.png" alt="Step 1.1" width="400"/> <br>
ternary_gtkwave

### Synthesizing 

Output of Show operation:


<img src="session12\show_ternary.png" alt="Step 1.1" width="400"/> <br>
show_ternary


## Invoking GLS

Run the command :

```
iverilog ../sky130RTLDesignAndSynthesisWorkshop/my_lib/verilog_model/primitives.v ../sky130RTLDesignAndSynthesisWorkshop/my_lib/verilog_model/sky130_fd_sc_hd.v

```

The gls output is

<img src="session12\gls_output.png" alt="Step 1.1" width="400"/> <br>


## For bad_mux Design File

Follow the same steps as above for bad_mux.v

 gtwave output for bad_mux

<img src="session12\bad_mux_gtkwave.png" alt="Step 1.1" width="400"/> <br>


## Synthesis Mismatch for Blocking Statement

Let us first do the RTL Simulation for the blocking_caveat.v file.

<img src="session12\blocking_caveat_gtkwave.png" alt="Step 1.1" width="400"/> <br>


Synthesisizing this design file using Yosys and observing the gtkwave waveform.

<img src="session12\blocking_caveat_gtkwave_last.png" alt="Step 1.1" width="400"/> <br>


If you observe this waveform and the previous waveform you will observe a synthesis mismatch. 


# Session 13: Synthesized Output Waveform Comparison with Behavioral Waveform

We are now trying to synthesise the RV_CPU.v design file from session Eight. Again we are using Yosys to generate the netlist and the mapped netlist verilog design from the RVMYTH core verilog file.


Use the following commands: 

```


read_liberty -lib ../sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib 

read_verilog RV_CPU.v 

synth -top RV_CPU

abc -liberty ../sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib 

write_verilog RV_CPU_net.v

```

Now use the command to run the GLS Simulation

```

iverilog -DFUNCTIONAL -DUNIT_DELAY=#1 -DPOST_SYNTH_SIM src/module/cpu_tb.v -I src/module/ -I src/include/ -I lib/verilog_models/


```

Use GTKWAVE to view the waveforms and the signals. The standard cells can also be viewed using this.

```
gtkwave post_synth_sim.vcd

```

Here are the two standard cells from RV_CPU_net.v that are shown in the gtkwave waveform 

<img src="session13\std_cell.png" alt="Step 1.1" width="600"/> <br>

The signals 'xor0_out_X' and 'nand0_out_Y' can be seen.



## Synthesized Window with Standard Cells and 'OUT' signal: 

<img src="session13\zoomed_out_gtkwave.png" alt="Step 1.1" width="700"/> <br>

*System user name visible as required.*

## Pre-Synthesis Behavioural Output From Session Eight for Comparison:

<img src="imagesssessionsix\gtk_waveform.png" alt="Step 1.1" width="700"/> <br>



## *Note*: For Reference if required.

1.  Observe the added 'out' waveform in it's default form as well to verify the functionality.

<img src="session13\sq_wave.png" alt="Step 1.1" width="700"/> <br>

2. Zoomed out synthesized gtkwave waveforms 

<img src="session13\zoomedout.png" alt="Step 1.1" width="700"/> <br>

3. Report 

<img src="session13\report.png" alt="Step 1.1" width="700"/> <br>





# Session 14: Using OpenSTA for Static Timing Analysis for Synthesized RISCV Core



## WHY STA?

The goal of STA is to verify that your design operates reliably at the intended clock speed without timing violations, ensuring that signals arrive within required time windows for each clock cycle.


**OpenSTA** is an **open-source Static Timing Analysis (STA) tool** used for analyzing and verifying the timing of digital circuits. It’s particularly useful in the digital design flow for ensuring that a circuit meets its timing requirements, which is essential for the correct operation of synchronous digital designs.

## Key Functions of OpenSTA:

1. **Timing Analysis**
   - OpenSTA calculates **signal propagation delays** across paths in your circuit to ensure that signals reach their destinations within a specified time (set by your clock period and constraints).
   - It performs both **setup timing analysis** (checking if data arrives at a register in time before the next clock edge) and **hold timing analysis** (ensuring data stays stable long enough after the clock edge to be latched correctly).

2. **Constraint Checking**
   - You can define various **timing constraints**, including clock definitions, clock uncertainties, signal transition times, and path delay limits. OpenSTA verifies that these constraints are met across all timing paths in the circuit.

3. **Delay Calculations Using Liberty Files**
   - OpenSTA relies on **Liberty (.lib) files**, which provide detailed timing information for the standard cells in your design (like NAND gates, flip-flops, etc.). This file specifies cell delays, setup/hold requirements, and other characteristics necessary for STA.

4. **Timing Reports**
   - OpenSTA generates timing reports that highlight paths where timing requirements are or aren’t met, allowing designers to identify and fix potential timing issues.


# Reg-to-Reg Path in Digital Design

In digital design, particularly in the context of Static Timing Analysis (STA), a **reg-to-reg path** refers to the timing path between two registers (flip-flops). It represents the flow of data from one register (the source register) to another register (the destination register) through combinational logic.

## Key Points

1. **Source and Destination**: 
   - The **source register** is where the data originates.
   - The **destination register** is where the data is clocked in.

2. **Combinational Logic**: 
   - The path includes all the combinational logic between the two registers, which can consist of gates and other logic elements.

3. **Timing Analysis**: 
   - In STA, analyzing reg-to-reg paths is crucial for determining whether the design meets its timing requirements, such as setup time and hold time. 
   - The timing path must be fast enough to ensure that data is correctly latched into the destination register before the next clock edge.

4. **Setup and Hold Times**:
   - **Setup Time**: The minimum time before the clock edge that the data must be stable.
   - **Hold Time**: The minimum time after the clock edge that the data must remain stable.

5. **Critical Paths**: 
   - A reg-to-reg path that takes a significant amount of time (close to the clock period) is often referred to as a **critical path**. 
   - Optimizing such paths is essential for improving overall circuit performance.

## Conclusion

Understanding reg-to-reg paths is fundamental for ensuring that a digital circuit operates reliably and at the desired speed. 






# Static Timing Analysis on RISCV Core using Custom Clock Time Period of 9.6ns 

Steps to run the commands:

## Load the Liberty Files

``` 
read_liberty -min ./lib/sta/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -max ./lib/sta/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -min ./lib/avsdpll.lib
read_liberty -max ./lib/avsdpll.lib
read_liberty -min ./lib/avsddac.lib
read_liberty -max ./lib/avsddac.lib
```

This file is essential for STA because it provides detailed cell characteristics such as delays, power, and setup/hold constraints.


## Load the Verilog Netlist


```
read_verilog src/module/vsdbabysoc.v
read_verilog -I src/include src/module/RV_CPU.v
read_verilog -I src/include src/module/clk_gate.v
```




## Link the Design 

``` link_design vsdbabysoc```




## Create the clock of 9.6ns (CUSTOM)

``` create_clock clk -period 9.6 [get_ports clk] ```

## Define Setup and Hold Constraints 

For SETUP

``` set_clock_uncertainty [expr 0.05*9.6] -setup [get_clocks clk]```

For Hold

``` set_clock_uncertainty [expr 0.08*9.6] -hold [get_clocks clk]```



## Define Clock Transition and Input Transition


Clock Transition

``` set_clock_transition [expr 0.05 * 10] [get_clocks clk] ```
 

Input Transition

```set_input_transition [expr 0.08 * 10] [all_inputs]```


## Combining every constraint into an sdc file: 



### Constraints Provided to OpenSTA in a sdc file are: 



```
set_units -time ns

create_clock [get_pins {pll/CLK}] -name clk -period 9.6
set_clock_uncertainty [expr 0.05 * 9.6] -setup [get_clocks clk]
set_clock_uncertainty [expr 0.08 * 9.6] -hold [get_clocks clk]
set_clock_transition [expr 0.05 * 9.6] [get_clocks clk]
set_input_transition [expr 0.08 * 9.6] [all_inputs]

```

## Invoke STA

Invoke STA and run the following command:

```
sta scripts/sta.conf
```


## sta.conf file contents:

```
read_liberty -min ./lib/sta/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -max ./lib/sta/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -min ./lib/avsdpll.lib
read_liberty -max ./lib/avsdpll.lib
read_liberty -min ./lib/avsddac.lib
read_liberty -max ./lib/avsddac.lib
read_verilog ./src/module/vsdbabysoc_synth.v
link_design vsdbabysoc
read_sdc ./src/sdc/sta_post_synth.sdc

```

## Timing Reports

## MAX DELAY : SETUP REPORT 

``` report_checks -path_delay max ```

<img src="session14\setup_new.png" alt="Step 1.1" width="700"/> <br>





## MIN DELAY : HOLD REPORT 

``` report_checks -path_delay min ```

<img src="session14\hold_new.png" alt="Step 1.1" width="700"/> <br>



The setup and hold reports allow you to verify that your design meets timing constraints across all paths.


# Session 15: PVT Corner Analysis Using OpenSTA


## Firstly, modify the sdc file as follows:

```
set_units -time ns
set PERIOD 9.6
create_clock [get_pins {pll/CLK}] -name clk -period $PERIOD
set_clock_uncertainty [expr 0.05 * $PERIOD] -setup [get_clocks clk]
set_clock_uncertainty [expr 0.08 * $PERIOD] -hold [get_clocks clk]
set_clock_transition [expr 0.05 * $PERIOD] [get_clocks clk]


set_input_transition [expr $PERIOD * 0.08] [get_ports ENB_CP]
set_input_transition [expr $PERIOD * 0.08] [get_ports ENB_VCO]
set_input_transition [expr $PERIOD * 0.08] [get_ports REF]
set_input_transition [expr $PERIOD * 0.08] [get_ports VCO_IN]
set_input_transition [expr $PERIOD * 0.08] [get_ports VREFH]

```


## Automating tcl script after adding all the libraries required:

```

set list_of_lib_files(1) "sky130_fd_sc_hd__ff_100C_1v65.lib"
set list_of_lib_files(2) "sky130_fd_sc_hd__ff_100C_1v95.lib"
set list_of_lib_files(3) "sky130_fd_sc_hd__ff_n40C_1v56.lib"
set list_of_lib_files(4) "sky130_fd_sc_hd__ff_n40C_1v65.lib"
set list_of_lib_files(5) "sky130_fd_sc_hd__ff_n40C_1v76.lib"
set list_of_lib_files(6) "sky130_fd_sc_hd__ff_n40C_1v95.lib"
set list_of_lib_files(7) "sky130_fd_sc_hd__ss_100C_1v40.lib"
set list_of_lib_files(8) "sky130_fd_sc_hd__ss_100C_1v60.lib"
set list_of_lib_files(9) "sky130_fd_sc_hd__ss_n40C_1v28.lib"
set list_of_lib_files(10) "sky130_fd_sc_hd__ss_n40C_1v35.lib"
set list_of_lib_files(11) "sky130_fd_sc_hd__ss_n40C_1v40.lib"
set list_of_lib_files(12) "sky130_fd_sc_hd__ss_n40C_1v44.lib"
set list_of_lib_files(13) "sky130_fd_sc_hd__ss_n40C_1v60.lib"
set list_of_lib_files(14) "sky130_fd_sc_hd__ss_n40C_1v76.lib"
set list_of_lib_files(15) "sky130_fd_sc_hd__tt_025C_1v80.lib"
set list_of_lib_files(16) "sky130_fd_sc_hd__tt_100C_1v80.lib"

for {set i 1} {$i <= [array size list_of_lib_files]} {incr i} {
read_liberty -min ./lib/timing/$list_of_lib_files($i)
read_liberty -max ./lib/timing/$list_of_lib_files($i)
read_liberty -min ./lib/avsdpll.lib
read_liberty -max ./lib/avsdpll.lib
read_liberty -min ./lib/avsddac.lib
read_liberty -max ./lib/avsddac.lib
read_verilog ./src/module/vsdbabysoc_synth.v
link_design vsdbabysoc
current_design
read_sdc ./src/sdc/sta_post_synth.sdc
check_setup -verbose
report_checks -path_delay min_max -fields {nets cap slew input_pins fanout} -digits {4} > ./output/sta_output/min_max_$list_of_lib_files($i).txt

exec echo "$list_of_lib_files($i)" >> ./output/sta_output/sta_worst_max_slack.txt
report_worst_slack -max -digits {4} >> ./output/sta_output/sta_worst_max_slack.txt

exec echo "$list_of_lib_files($i)" >> ./output/sta_output/sta_worst_min_slack.txt
report_worst_slack -min -digits {4} >> ./output/sta_output/sta_worst_min_slack.txt

exec echo "$list_of_lib_files($i)" >> ./output/sta_output/sta_tns.txt
report_tns -digits {4} >> ./output/sta_output/sta_tns.txt

exec echo "$list_of_lib_files($i)" >> ./output/sta_output/sta_wns.txt
report_wns -digits {4} >> ./output/sta_output/sta_wns.txt
}

```

Run the tickle script using `` source scripts/sta_pvt.tcl `` after invoking STA.

## Observe the graph for WORST SETUP SLACK


<img src="session15\WSS.png" alt="Step 1.1" width="700"/> <br>

## Observe the graph for WORST HOLD SLACK 

<img src="session15\WHS.png" alt="Step 1.1" width="700"/> <br>


## Tabulated Data for Analysis

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Library File</th>
      <th>Total Negative Slack (TNS)</th>
      <th>Worst Negative Slack (WNS)</th>
      <th>Worst Setup Slack (Worst Slack)</th>
      <th>Worst Hold Slack (Worst Slack)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>sky130_fd_sc_hd__ff_100C_1v65.lib</th>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>0.4971</td>
      <td>-0.4873</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ff_100C_1v95.lib</th>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>2.8533</td>
      <td>-0.5456</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ff_n40C_1v56.lib</th>
      <td>-882.4417</td>
      <td>-4.1696</td>
      <td>-4.1696</td>
      <td>-0.4274</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ff_n40C_1v65.lib</th>
      <td>-90.2764</td>
      <td>-1.7243</td>
      <td>-1.7243</td>
      <td>-0.4672</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ff_n40C_1v76.lib</th>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>0.2759</td>
      <td>-0.5024</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ff_n40C_1v95.lib</th>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>2.3575</td>
      <td>-0.5447</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_100C_1v40.lib</th>
      <td>-17369.2031</td>
      <td>-24.5954</td>
      <td>-24.5954</td>
      <td>0.2416</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_100C_1v60.lib</th>
      <td>-8776.0078</td>
      <td>-13.2513</td>
      <td>-13.2513</td>
      <td>-0.0346</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_n40C_1v28.lib</th>
      <td>-80141.5078</td>
      <td>-116.8746</td>
      <td>-116.8746</td>
      <td>1.1419</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_n40C_1v35.lib</th>
      <td>-50034.0312</td>
      <td>-71.7738</td>
      <td>-71.7738</td>
      <td>0.6764</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_n40C_1v40.lib</th>
      <td>-38274.2734</td>
      <td>-54.2779</td>
      <td>-54.2779</td>
      <td>0.4536</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_n40C_1v44.lib</th>
      <td>-32302.1211</td>
      <td>-45.6330</td>
      <td>-45.6330</td>
      <td>0.3163</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_n40C_1v60.lib</th>
      <td>-15624.2334</td>
      <td>-22.6242</td>
      <td>-22.6242</td>
      <td>-0.0133</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__ss_n40C_1v76.lib</th>
      <td>-9080.3398</td>
      <td>-13.6280</td>
      <td>-13.6280</td>
      <td>-0.2276</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__tt_025C_1v80.lib</th>
      <td>-258.9802</td>
      <td>-2.4932</td>
      <td>-2.4932</td>
      <td>-0.4250</td>
    </tr>
    <tr>
      <th>sky130_fd_sc_hd__tt_100C_1v80.lib</th>
      <td>-101.6824</td>
      <td>-1.7136</td>
      <td>-1.7136</td>
      <td>-0.4267</td>
    </tr>
  </tbody>
</table>

## Total Negative Slack Graph

<img src="session15\TNS.png" alt="Step 1.1" width="700"/> <br>



## Worst Negative Slack Graph 

<img src="session15\WNS.png" alt="Step 1.1" width="700"/> <br>




Note: The python script for automating this process is present in the repository to source for usage.




# Session 16: Inception of open-source EDA, OpenLANE and Sky130 PDK


## RISCV Introduction

The field of computer architecture and processor design has embraced the open-source RISC-V instruction set architecture (ISA). It was first created in 2010 at the University of California, Berkeley, and has since expanded to include researchers and business professionals from all around the world. The simplicity and modularity of RISC-V are its primary features. It adheres to the design concept of Reduced Instruction Set Computers (RISC), which places an emphasis on a condensed and simplified set of instructions that are simple to decode and carry out. The "RV32I," a foundation set of instructions provided by RISC-V, performs crucial tasks for general-purpose computing. To satisfy certain application needs, other optional instruction sets can be added, such as RV64G for 64-bit computation or RV32F for single-precision floating-point operations. 


One of the primary advantages of RISC-V is its open nature. Because the ISA specifications, reference implementations, and software tools are publicly available, anybody can study, modify, or implement their own RISC-V processors without having to pay for a license or face other restrictions. This openness has led to the creation of a vibrant ecosystem of researchers, software engineers, and hardware designers who collaborate to advance and create around the RISC-V architecture.

## Simplified RTL to GDSII flow
The RTL to GDSII flow basically involves :

1. RTL Design - The process begins with the RTL design phase, where the digital circuit is described using a hardware description language (HDL) like VHDL or Verilog. The RTL description captures the functional behavior of the circuit, specifying its logic and data paths.

2. RTL Synthesis - RTL synthesis converts the high-level RTL description into a gate-level netlist. This stage involves mapping the RTL code to a library of standard cells (pre-designed logic elements) and optimizing the resulting gate-level representation for area, power, and timing. The output of RTL synthesis is typically in a format called the gate-level netlist.

3. Floor and Power Planning - is a crucial step in the digital design flow that involves partitioning the chip's area and determining the placement of major components and functional blocks. It establishes an initial high-level layout and defines the overall chip dimensions, locations of critical modules, power grid distribution, and I/O placement.The primary goals of floor planning are: Area Partitioning, Power Distribution, Signal Flow and Interconnect Planning, Placement of Key Components, Design Constraints and Optimization.

4. Placement - Placement involves assigning the physical coordinates to each gate-level cell on the chip's layout. The placement process aims to minimize wirelength, optimize signal delay, and satisfy design rules and constraints. Modern placement algorithms use techniques like global placement and detailed placement to achieve an optimal placement solution.

5. Clock Tree Synthesis - Clock tree synthesis (CTS) is a crucial step in the digital design flow that involves constructing an optimized clock distribution network within an integrated circuit (IC). The primary goal of CTS is to ensure balanced and efficient clock signal distribution to all sequential elements (flip-flops, registers) within the design, minimizing clock skew and achieving timing closure.

6. Routing - Routing connects the gates and interconnects on the chip based on the placement information. It involves determining the optimal paths for the wires and vias that carry signals between different components. The routing process needs to adhere to design rules, avoid congestion, and optimize for factors like signal integrity, power, and manufacturability.

7. Sign-off - Sign-off analysis refers to the final stage of the electronic design process, where comprehensive verification and analysis are performed to ensure that the design meets all the necessary requirements and specifications. It involves a series of checks and simulations to confirm that the design is ready for fabrication and meets the desired functionality, performance, power, and reliability targets.

8. GDSII File Generation - Once the layout is verified and passes all checks, the final step is to generate the GDSII file format, which represents the complete physical layout of the chip. The GDSII file contains the geometric information necessary for fabrication, including the shapes, layers, masks, and other relevant details.


### Commands


``cd Desktop/work/tools/openlane_working_dir/openlane``


Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command

``docker``.


 Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command

``./flow.tcl -interactive``

Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow

``package require openlane 0.9``

Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'

``prep -design picorv32a``

Now that the design is prepped and ready, we can run synthesis using following command

``run_synthesis``







## Images


<img src="images_session16/synthesis_success.png" alt="Step 1.1" width="700"/> <br>


Overall Layout Zoomed Out:

<img src="images_session16/zoomed_out_layout.png" alt="Step 1.1" width="700"/> <br>

Overall Layout Zoomed In: 

<img src="images_session16/zoomed_inlayout.png" alt="Step 1.1" width="700"/> <br>


Selecting a particular cell by hovering the mouse and pressing S, one on the tcl console run the command ``what``.

<img src="images_session16/what_command.png" alt="Step 1.1" width="700"/> <br>


## Results

<img src="images_session16/result_1.png" alt="Step 1.1" width="700"/> <br>


## Flops ratio
The flop ratio is defined as the ratio of the number of flops to the total number of cells, here it is 1613/14876 = 0.108

### TNS -759.46ns

### WNS -24.89ns



# Session 17: CHIP FLOORPLANNING

## Floorplanning Stages in VLSI Design

## 1. Pre-Placed Cells
- In VLSI design, certain complex logic blocks or third-party modules are treated as black boxes with defined input/output ports and clocks. These blocks are either **macros** or **IPs**:
  - **Macros**: Modules like CPU cores that are developed in-house by the chip manufacturer.
  - **IPs (Intellectual Property)**: Pre-designed modules obtained from third-party vendors or in-house developed hard IPs, such as SRAM, PLLs, and protocol converters.

- During floorplanning, these macros and IPs are strategically placed within the core area before standard cells and power routing are added. The goal is to position frequently interconnected cells close to each other and orient them to optimize input and output connectivity.

## 2. Decoupling Capacitors for Pre-Placed Cells
- The power supply lines in a chip can exhibit resistance, inductance, and capacitance (RLC effects), leading to voltage drops or fluctuations at the power or ground nodes of blocks. This can result in improper logic transitions, potentially driving signals into an undefined (forbidden) state.
- To prevent this, **decoupling capacitors** are added between the power (Vdd) and ground (Gnd) nodes of these blocks. These capacitors act as local energy reservoirs, smoothing out voltage fluctuations during logic transitions.

## 3. Power Planning
- With many cells drawing power from the same rail, issues like **voltage droop** and **ground bounce** can occur:
  - **Voltage Droop**: A drop in the Vdd voltage when many cells switch from high (1) to low (0) simultaneously.
  - **Ground Bounce**: A rise in the ground potential above 0V when many cells switch from low (0) to high (1) simultaneously.

- These effects can push signal levels outside the acceptable noise margins, risking logic errors. To mitigate this, a **power grid** is created with horizontal and vertical tracks for Vdd and Gnd. Cells close to these intersections can efficiently tap power or sink current, maintaining stable voltage levels.

## 4. Pin Placement
- Input, output, and clock pins are positioned to minimize routing complexity and reduce delays. In tools like **OpenLane**, various pin placement strategies are employed, such as:
  - **Random Pin Placement**: Pins are placed without a specific order.
  - **Uniformly Spaced Pin Placement**: Pins are evenly distributed along the periphery to optimize routing paths and minimize congestion.

By following these stages, the floorplanning process aims to enhance performance, reduce routing complexity, and ensure stable power delivery in VLSI design.


### Run Floorplan

``run_floorplan``


### Change directory to path containing generated floorplan def


``cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/17-03_12-06/results/floorplan``

### Command to load the floorplan def in magic tool


``magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def ``



## Running Placement 

`` run_placement``

## Run the command to load the placement def in magic tool

```
magic -T ../../../../../../../pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def

```


## Complete Floorplan 


<img src="session17/complete_floorplan.png" alt="Step 1.1" width="700"/> <br>

## Zoomed In Floorplan

<img src="session17/floorplan_zoomed.png" alt="Step 1.1" width="700"/> <br>

## `What` Command by hovering overing the cell and pressing s 

<img src="session17/what.png" alt="Step 1.1" width="700"/> <br>



# Session 18: Design Library Cells Using Magic 

Run the following commands:


## Introduction to VSD Inverter and Layout Visualization using Magic Tool

Clone the VSD Standard Cell Design Repository and view the layout of the inverter using Magic Tool.


```
git clone https://github.com/nickson-jose/vsdstdcelldesign.git
cd vsdstdcelldesign
cp /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech .
magic -T sky130A.tech sky130_arn_inv.mag &
```
## Layout of the Inverter with name 'arnav'


<img src="session18/arn_inv.png" alt="Step 1.1" width="700"/> <br>


### Zoomed In


<img src="session18/zoomed_inv.png" alt="Step 1.1" width="700"/> <br>


Use the following commands in the Magic tool's tkcon window to extract the SPICE netlist from your custom inverter layout:

```
pwd
extract all
ext2spice cthresh 0 rthresh 0
ext2spice
```

### Spice list


<img src="session18/spice_list.png" alt="Step 1.1" width="700"/> <br>

## Inception of Layout and CMOS Fabrication Process


## 16-Mask CMOS Fabrication
16-Mask CMOS Fabrication encompasses several critical phases for crafting integrated circuits.

### Substrate Selection.
This is the most initial phase of the process where the subrstrate is chosen.Here we are chosing a p-substrate.

<img src="session18/substrate_selection.png" alt="Step 1.1" width="700"/> <br>

### Active Region Creation

To isolate the active regions for transistors, the process starts with the deposition of SiO₂ (silicon dioxide) and Si₃N₄ (silicon nitride) layers. This is followed by photolithography and etching of the silicon nitride layer. This method is known as LOCOS (Local Oxidation of Silicon), where an oxide layer is grown in specific areas to define the active regions. Finally, the Si₃N₄ layer is removed using hot H₂SO₄ (sulfuric acid).

<img src="session18/active_region.png" alt="Step 1.1" width="700"/> <br>


### N-Well and P-Well Formation
The N-well and P-well regions are formed independently. For P-well formation, boron ions are implanted, while for N-well formation, phosphorus ions are used. A high-temperature furnace process is then applied to drive-in the diffusion of these ions, establishing the well depths in a step commonly referred to as the tub process.

<img src="session18/nwellpwell.png" alt="Step 1.1" width="700"/> <br>


### Gate Formation 

The gate is a crucial terminal in CMOS transistors, as it regulates the threshold voltage for transistor switching. The gates for both NMOS and PMOS transistors are created using photolithography techniques. Key factors in gate formation include the oxide capacitance and the doping concentration, which influence the transistor's performance.


<img src="session18/gateformation.png" alt="Step 1.1" width="700"/> <br>

### Lightly dopped Drain(LDD).

LDD formed to avoid the hot electron effect.


<img src="session18/ldd.png" alt="Step 1.1" width="700"/> <br>


### Source and Drain Formation

Screen oxide added to avoid channelling during implants followed by Aresenic implantation and high temperature annealing.


<img src="session18/source_drain_formation.png" alt="Step 1.1" width="700"/> <br>

### Local Interconnect Formation

The screen oxide layer is removed using HF etching, followed by the deposition of titanium (Ti) to create low-resistance contacts. Heat treatment is then applied, leading to chemical reactions that form titanium silicide at the contact points for low-resistance interconnects, and titanium nitride at the top-level connections, facilitating local signal routing.


<img src="session18/local_interconnect.png" alt="Step 1.1" width="700"/> <br>


### Higher Level Metal Formation

Chemical Mechanical Polishing (CMP) is performed by doping silicon oxide with boron or phosphorus to achieve surface planarization. This process is followed by the deposition of titanium nitride (TiN) and tungsten. An aluminum (Al) layer is then deposited, patterned using photolithography, and further polished with CMP. This forms the first interconnect layer. Additional interconnect layers can be stacked on top to achieve higher levels of metal connections. Finally, a dielectric layer, typically Si₃N₄ (silicon nitride), is added on top to protect the chip.

<img src="session18/higher_level_metal.png" alt="Step 1.1" width="700"/> <br>



## Complete SPICE Deck for Inverter


Next, we modify the generated SPICE file to make necessary adjustments before running simulations. The SPICE file includes the definitions for NMOS and PMOS models, along with the subcircuit details. It also contains information on parasitic capacitances and other relevant parameters.


1. VGND to VSS 0V
2. Supply Voltage VPWRD to GND
3. Sweeping a pulse input
4. We add library files and change the scale to 0.01u
5. Add a transient analysis with necessary stoptime and precision as shown below

















# Session 19: Timing Analysis and Clock Tree Synthesis

## Normal Cell LEF production
Complete mag information is not required for placement. All that is needed are the cell's PR border, I/O ports, power, and ground rails. The LEF file defines this information. Lef extraction from the mag file and integration into our design processes are the primary goals.


## Enter the track information grid.
A track is a route that is used to draw metal layers for routing.It is employed to specify the standard cell's height.

## Rules to adhere to when creating a standard cell:

1. On both horizontal and vertical tracks, input and output ports must be located at the intersection.
2. The standard cell's width and height must be in the odd multiples of the track pitch and height, respectively.
   
``Tracks.info`` contains the information needed to obtain the grids; cd to the specific directory and open the file.


Below are the contents of the file: 

```
li1 X 0.23 0.46  
li1 Y 0.17 0.34   
met1 X 0.17 0.34
met1 Y 0.17 0.34
met2 X 0.23 0.46
met2 Y 0.23 0.46
met3 X 0.34 0.68
met3 Y 0.34 0.68
met4 X 0.46 0.92
met4 Y 0.46 0.92
met5 X 1.70 3.40
met5 Y 1.70 3.40
```



(SOME PHOTO before grid on)




Use the below command in the tkcon window to get grid on magic.

```
grid 0.46um 0.34um 0.23um 0.17um
```




(SOME PHOTO after grid on)




## Creating Port Definition

The cell's pins require specific definitions and properties to be configured. A port-containing cell in an LEF file is written as a macro cell, and the ports are specified as the macro's PINs.

The instructions below outline how to define a port using Magic Console:

1. Source the design's.mag file (in this case, the inverter) in the Magic Layout window.
2.  Next, select Edit >> Text to bring up a dialog box.
3. The string name and size are immediately entered into the text when you double-press S at the I/O labels. Make sure the default checkbox is unchecked and the port enable checkbox is selected. 

(SOME PHOTO )


4. The sequence in which the ports will be written in the LEF file is indicated by the number in the text field next to the enable checkbox (0 being the first).

5. The definition of the ground and power layers may differ from that of the signal layer. In this case, metal1 provides the ground and power connectivity.



## Configure the layout's port class and port use properties


Port class and port use attributes are set after ports have been defined.

Select Port A in magic

```
port class input
port use signal
```

Select Y area

```
port class output
port use signal
```

Select VPWR area
```
port class inout
port use power
```

Select VGND area
```
port class inout
port use ground
```


## Custom Cell Naming and LEF Extraction

Using the tkcon window, give the custom cell the name ``sky130_vsdinv.mag``.

We generate lef file by command ``lef write``.

``sky130_vsdinv.lef`` file is generated.

(PHOTO OF THE ABOVE FILE)


## Including Custom Cells in ASIC Design 

In the first stages of an inverter, we produced a proprietary standard cell. Move the lef files, sky130_fd_sc_hd_typical.lib, sky130_fd_sc_hd_slow.lib, and sky130_fd_sc_hd_fast.lib from the libs folder vsdstdcelldesign to the picorv32a's src folder. Next, make the following changes to config.tcl.


(SOME TCL SCRIPT)


```

# Design
set ::env(DESIGN_NAME) "picorv32a"

set ::env(VERILOG_FILES) "$::env(DESIGN_DIR)/src/picorv32a.v"

set ::env(CLOCK_PORT) "clk"
set ::env(CLOCK_NET) $::env(CLOCK_PORT)

set ::env(GLB_RESIZER_TIMING_OPTIMIZATIONS) {1}

set ::env(LIB_SYNTH) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"
set ::env(LIB_SLOWEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib"
set ::env(LIB_FASTEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib"
set ::env(LIB_TYPICAL) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"

set ::env(EXTRA_LEFS) [glob $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/src/*.lef]

set filename $::env(DESIGN_DIR)/$::env(PDK)_$::env(STD_CELL_LIBRARY)_config.tcl
if { [file exists $filename] == 1} {
	source $filename
}
```


To integrate standard cell in openlane flow after make mount , perform following commands:

```
prep -design picorv32a -tag RUN_2023.09.09_20.37.18 -overwrite 
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
run_synthesis

```

### Synthesis Report 

(SYNTHESIS REPORT PHOTO)

### STA Report 

(STA Report PHOTO)


## Delay Tables 


In essence, delay is a parameter that significantly affects our design cells. All other temporal factors are determined by delay. A delay model table that can be used as a timing table is made for cells with varying sizes and threshold voltages. A cell's delay is determined by its input transition and output load. Consider the following two scenarios: a long wire with the cell (X1) at its end; the delay of this cell will differ due to the poor transition produced by the resistance and capacitances on the long wire. 

Since the tarn is not as bad as it was in the previous situation, the delay for the same cell that is sitting at the end of the short cable will be different. Despite being identical cells, the delay changed based on the input text. The same is true for o/p load.

In order to maintain signal integrity, VLSI engineers have determined some limitations while adding buffers. They have observed that while the size of each buffer level must remain constant, the load they drive can affect how long it takes. In order to solve this, they developed the idea of "delay tables," which are essentially 2D arrays with values for load capacitance and input slew that are connected to various buffer sizes. The design uses these tables as timing models.

The algorithm uses the supplied input slew and load capacitance values to calculate the corresponding delay values for the buffers when working with these delay tables. The program uses an interpolation technique to identify the nearest available data points and extrapolates from them to estimate the necessary delay values in situations when the precise delay data is not easily accessible.

(SOME PHOTO)

## Openlane steps with custom standard cell

We perform synthesis and found that it has positive slack and met timing constraints.

During Floorplan, ``504 endcaps, 6731 tapcells`` got placed. Design has 275 original rows

Now  ``run_placement``.

Following placement, we verify legality and use magic from the results/placement directory to verify the layout:

```
magic -T /home/parallels/OpenLane/vsdstdcelldesign/libs/sky130A.tech lef read tmp/merged.nom.lef def read results/floorplan/picorv32a.def &
```

(USE YOUR OWN COMMAND)

(SOME PHOTO)



## Post Synthesis Timing Analysis Using OpenSTA

The OpenSTA tool is used to perform timing analysis outside of the openLANE flow. To do the STA analysis, pre_sta.conf is necessary.

Use the following command to invoke OpenSTA outside of the openLANE flow:

``sta pre_sta.conf``.

sdc file for OpenSTA is modified like this:

base.sdc is located in vsdstdcelldesigns/extras directory therefor, copy it into your design folder.


Clock is regarded as ideal during the placement step since it is disseminated only after CTS is completed. Therefore, before CTS, only setup slack is taken into account.

The PLL, which has an integrated circuit with cells and some logic, generates the clock. Depending on the circuit, there may be differences in the clock generation. Clock uncertainty is the collective term for these differences. Jitter is one of the parameters in that. The clock might arrive at that precise moment without any deviation, but that is unclear. It is known as clock_uncertainty for this reason. Margin, Jitter, and Skew enter clock_uncertainty.

## Clock Tree Synthesis Using Tinoncts

There are several approaches to implement clock tree synthesis (CTS), and the particular methodology chosen will rely on the design objectives, constraints, and needs. The following are a few varieties or methods of clock tree synthesis:

### Balanced Tree CTS 
In a balanced tree CTS, the clock signal is distributed in a balanced manner, often resembling a binary tree structure. This approach aims to provide roughly equal path lengths to all clock sinks (flip-flops) to minimize clock skew. It's relatively straightforward to implement and analyze but may not be the most power-efficient solution.

### H-Tree CTS
 The hierarchical tree structure of an H-tree CTS is shaped like the letter "H." It works especially well for spreading clock signals over sizable chip regions. The hierarchical structure helps minimize power usage and lessen clock skew.

### Star CTS
A star CTS distributes the clock signal to each flip-flop from a single central point, which resembles a star. This method reduces clock skew and streamlines clock distribution, although it might necessitate more buffers close to the source.

### Global-Local CTS
 Global-Local CTS is a hybrid approach that combines elements of both star and tree topologies. The global clock tree distributes the clock signal to major clock domains, while local trees within each domain further distribute the clock. This approach balances between global and local optimization, addressing both chip-wide and domain-specific clocking requirements.

### Mesh CTS
 In a mesh CTS, clock wires are arranged in a mesh-like grid pattern, and each flip-flop is connected to the nearest available clock wire. It is often used in highly regular and structured designs, such as memory arrays. Mesh CTS can offer a balance between simplicity and skew minimization.

 ### Adaptive CTS 
 Adaptive CTS methods dynamically modify the clock tree structure in response to the design's timing and congestion limitations. Although this method may be more difficult to execute, it offers more flexibility and adaptability in achieving design objectives.

 ## LAB
 This step involves propagating the clock and ensuring that it reaches every clock pin from the clock source with the least amount of skew and insertion delay possible. We use the midpoint technique to implement the H-tree in order to do this. We employ clock inputs or buffers in the clock pipeline to balance the skews. If the slack was tried to be decreased in a prior run of the TritonCTS tool before attempting to execute CTS, cell replacement procedures may have altered the netlist. Consequently, the write_verilog command must be used to alter the verilog file. The synthesis, floorplan, and placement are then performed one more. Use the following command to launch CTS:

 ``run_cts``.

 After CTS run, my slack values are setup:12.97,Hold:0.23


 (MODIFY THE COMMAND)


 At this point, we use actual clocks to do timing analysis because the clock is propagated. Operaoad now conducts post-CTS analysis in the open-lane flow.

```
 openroad
read_lef <path of merge.nom.lef>
read_def <path of def>
write_db pico_cts.db
read_db pico_cts.db
read_verilog /home/parallels/OpenLane/designs/picorv32a/runs/RUN_09-09_11-20/results/synthesis/picorv32a.v
link_design picorv32a
read_liberty $::env(LIB_SYNTH_COMPLETE)
read_sdc /home/parallels/OpenLane/designs/picorv32a/src/my_base.sdc
set_propagated_clock (all_clocks)
report_checks -path_delay min_max -format full_clock_expanded -digits 4
```

(MODIFY THE COMMAND)

### HOLD SLACK 

(PHOTO)


### SETUP SLACK 

(PHOTO)


## Testing

```
echo $::env(CTS_CLK_BUFFER_LIST)
set $::env(CTS_CLK_BUFFER_LIST) [lreplace $::env(CTS_CLK_BUFFER_LIST) 0 0]
echo $::env(CTS_CLK_BUFFER_LIST)

```

Run cts once more after loading the placement stage def file after making the necessary changes. Run OpenROAD once more, create a new database, and follow the same steps. Following post_cts, the report is

Setup slack - 2.2379 , Hold slack - 0.1869

(WRITE YOUR OWN VALUES)


# Session 20: Final Steps for RTL2GDS

## Maze Routing and Lee's algorithm

Maze's Routing and Lee's Algorithm are classic techniques used in VLSI design for finding paths in a grid or PCB routing, as well as in various graph traversal and pathfinding applications.

## Maze Routing Algorithm
Maze's routing refers to a class of algorithms used to find a path between two points in a grid-based system. The most common approach is to use wave propagation from the source point until it reaches the destination. It is similar in concept to Lee's algorithm but is more general and may include various optimizations.

### Key Characteristics:

1. Wave Expansion: Expands wavefront from the source point until it reaches the target.

2. Guaranteed Solution: It always finds a path if one exists.
3. Applicable for VLSI: It is particularly useful in VLSI routing for connecting points without crossing over existing paths or obstacles.


### Steps:

1. Start at the source point.
2. Expand the search outward to all neighboring cells, marking the distance from the source.
3. Continue the expansion until you reach the destination.
4. Trace back from the destination to the source to find the path.



## Lee's Algorithm

Lee's Algorithm is a specific implementation of Maze's Routing, designed for breadth-first search (BFS) on a grid. It is commonly used for pathfinding in grids with obstacles, and it is popular due to its simplicity and guarantee of finding the shortest path.

### Key Features:

1. Breadth-First Search (BFS): Expands the search in all directions evenly.
2. Shortest Path: Finds the shortest path in an unweighted grid, making it useful for solving maze problems.
3. Wave Propagation: Utilizes wavefront propagation to explore the grid systematically.
4. Guaranteed Solution: It finds the shortest path if one exists.


### Steps:

1. Initialization:
  
Mark the source point with 0.
Create a queue and enqueue the source point.

2. Propagation:
 
 Dequeue the current point, check its neighboring cells (up, down, left, right).
If a neighboring cell is empty, mark it with the current distance + 1 and enqueue it.
Continue the process until reaching the destination or exhausting all possibilities.

3. Backtracking
 
If the destination is reached, backtrack from the destination to the source using the recorded distances to trace the shortest path.



However, the Lee algorithm has limitations. It essentially constructs a maze and then numbers its cells from the source to the target. While effective for routing between two pins, it can be time-consuming when dealing with millions of pins. There are alternative algorithms that address similar routing challenges.


## Design Rule Check (DRC)

DRC confirms if a design complies with the established process technology guidelines provided by the foundry for its production. DRC checking guarantees that the design satisfies manufacturing requirements and won't cause a chip failure, making it a crucial component of the physical design pipeline. It describes the chip's quality. Let's take a look at a handful of the numerous DRCs.

### Guidelines for physical wire design

Minimum wire width, minimal distance between the cables, the wire's minimum pitch we take the metal layer and place it on top of the upper metal layer to address the signal short violation. We verify using rules, width, and spacing.


## Power Distribution Network Generation


In contrast to the standard ASIC flow, OpenLANE's design does not include Power Distribution Network generation. PDN needs to be produced following CTS and post-CTS STA evaluations.

By looking at the current def environment variable, we can determine whether or not PDN has been created:  ``echo $::env(CURRENT_DEF)``.

```
prep -design picorv32a -tag <RUN file name>
gen_pdn

```

(SOME PHOTO)

(SOME PHOTO)

1. ``gen_pdn`` Generates the power distribution network.

2. The power distribution network has to take the design_cts.def as the input def file.

3. Power rings,strapes and rails are created by PDN.

4. From VDD and VSS pads, power is drawn to power rings.

5. Next, the horizontal and vertical strapes connected to rings draw the power from strapes.

6. Stapes are connected to rings and these rings are connected to std cells. So, standard cells get power from rails.

7.  In this design, straps are at metal layer 4 and 5 and the standard cell rails are at the metal layer 1. Vias connect accross the layers as required.
   
## Routing


The routing process in Electronic Design Automation (EDA) tools, including OpenLANE and commercial EDA tools, is particularly complex because of the large design space. The routing process is usually split into two separate steps, Global Routing and Detailed Routing, to simplify this complexity.


These two stages are handled by the following two routing engines:

### Global Routing
A coarse 3D routing graph is used to depict the routing region at this stage, which is separated into rectangular grid cells. The "FASTE ROUTE" engine is responsible for completing this assignment.

### Detailed Routing
In this case, the physical wiring is implemented using routing guides and a finer grid granularity. At this point, the "tritonRoute" engine is activated. While "Triton Route" uses the Global Route data to further improve the routing and implement a variety of strategies and optimizations to find the best way for connecting the pins, "Fast Route" creates the first routing guidance.














































































---











    
